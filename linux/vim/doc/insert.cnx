*insert.txt*    适用于 Vim version 9.1.  最后修订: 2025 Apr 14


		  VIM REFERENCE MANUAL    by Bram Moolenaar


						*Insert* *Insert-mode*
插入和替换文本		 				*mode-ins-repl*

本文档的大多数内容是关于插入和替换模式的. 文档末尾有少部分用其他方式插入文本的
命令

可以再用户手册24章|usr_24.txt|查看常用命令的概览. 

1. 特殊按键						|ins-special-keys|
2. 特殊的特殊按键					|ins-special-special|
3. 'textwidth' 及 'wrapmargin' 选项			|ins-textwidth|
4. 'expandtab', 'smarttab' 及 'softtabstop'  选项	|ins-expandtab|
5. 替换模式						|Replace-mode|
6. 虚拟替换模式						|Virtual-Replace-mode|
7. 插入模式补全						|ins-completion|
8. 插入模式命令						|inserting|
9. Ex插入命令						|inserting-ex|
10. 插入文件内容					|inserting-file|

查阅'virtualedit'选项以移动光标到不存在字符的位置. 这在编辑表格时是很有效的. 

==============================================================================
1. 特殊按键						*ins-special-keys*

在插入模式和替换模式中, 下面这些字符具有特殊意义; 其他字符则被直接插入. 使用
CTRL-V可以将这些特殊字符插入到缓冲区中. 如可以使用"CTRL-V CTRL-@"或"CTRL-V 000"
插入<Nul>字符. 在有些协同, 则需要使用"CTRL-V 003"插入CTRL-C. 注意: 如果CTRL-V
被映射了, 可以使用CTRL-Q代替|i_CTRL-Q|.

如果插入文本的时候正在特殊语言模式中工作, 查阅'langmap'选项|'langmap'|以避免反
复切换模式. 

如果设置了'insertmode'选项, <Esc>及一些其他的按键则会有另外的意义.
查阅|'insertmode'|.

char		action	~
-----------------------------------------------------------------------
						*i_CTRL-[* *i_<Esc>*
<Esc> or CTRL-[	结束插入或替换模式并返回普通模式. 如果是缩写还会对其进行扩展. 
		注意: 如果<Esc>在键在键盘上不好按尝试训练自己使用CTRL-[.
		如果使用的是Mac且Esc不生效, 尝试使用CTRL-<Esc>.或禁止辅助功能
		偏好的监听. >
		CTRL-[是ascii编码控制字符Esc的字面量. 即
<						*i_CTRL-C*
CTRL-C		退出插入模式并返回普通模式. 不检查缩写. 不触发|InsertLeavel|
		自动命令事件. >
		CTRL-C是ascii编码控制字符Etx的字面量. 即
<
						*i_CTRL-@*
CTRL-@		插入上一次被插入的文本并退出插入模式. 

						*i_CTRL-A*
CTRL-A		插入上一次被插入的文本. 

						*i_CTRL-H* *i_<BS>* *i_BS*
<BS> or CTRL-H	删除光标前面的字符 (查阅文档|i_backspacing|关于合并多行的内容) 
		查阅|:fixdel|命令, 如果<BS>键的行为不符合预期. 

						*i_<Del>* *i_DEL*
<Del>		删除光标位置的字符. 如果光标在行尾且'backspace'选项包含"eol"则会
		删除换行符; 下一行的内容将会添加到当前行的末尾.  
		查阅|:fixdel|命令, 如果<Del>键的行为不符合预期. 
						*i_CTRL-W*
CTRL-W		删除光标位置前面的单词 (查阅|i_backspacing|关于合并多行内容). 
		查阅"word motions"章节|word-motions|获取单词的定义. 
						*i_CTRL-U*
CTRL-U		删除当前行光标前面所有键入的字符.如果没有新键入的字符且'backspace'
		选项不为空则删除当前行光标前面的所有字符. 
		如果C-indenting被启用, Vim将会在行内容为空时调整缩进. 
		查阅|i_backspacing|关于合并多行内容的文档. 
						*i_CTRL-I* *i_<Tab>* *i_Tab*
<Tab> or CTRL-I 插入一个制表符. 如果'expandtab'选项被启用则会插入相同数量的空格.
		(使用CTRL-V <Tab>避免扩展, 如果CTRL-V被映射了使用CTRL-Q <Tab>, 
		|i_CTRL-Q|), 查阅'smarttab'选项及|ins-expandtab|文档. >
		CTRL-I是ascii编码控制字符HT的字面量. 即^I	Horizontal tab
<						*i_CTRL-J* *i_<NL>*
<NL> or CTRL-J	开始新行(换行) >
		CTRL-J时ascii编码控制字符LF的字面量. 即^J	Line feed
		有意思的是CTRL-V CTRL-@和CTRL-V CTRL-J的字面量都是^@, Vim应该
		对输入行为做了处理. 
<						*i_CTRL-M* *i_<CR>*
<CR> or CTRL-M	开始新行(回车) >
		CTRL-M时ascii编码控制字符CR的字面量. 即	Carriage return
						*i_CTRL-K*
CTRL-K {char1} [char2]
		输入复合字(查阅|digraph|文档). 当{char1}是特殊键时, 对应的键会
		被<>形式包裹. 比如, 字符串"<S-Space>"可以通过<C-K><S-Space>键入
		(两个按键). 字符不会被映射处理. 

CTRL-N		查找下一个关键字 (查阅|i_CTRL-N|) 
CTRL-P		查找上一个关键字 (查阅|i_CTRL-N|)

CTRL-R {register}				*i_CTRL-R*
		插入寄存器中的内容. 在键入CTRL-R和第二个字符之间, '"'将会被显示
		以表明期望输入寄存器的名字. 
		文本就像按键输入那样被插入到缓冲区, 但是映射及缩写不会被应用. 
		如果'textwidth', 'formatoptions'活着'autoindent'选项被启用, 这
		会影响被插入的内容. 这与"p"命令及使用鼠标产生的粘贴行为是不同的.
		特殊寄存器: 
			'"'	匿名寄存器, 包含上次删除或复制的文本. 
			'%'	当前文件名称.
			'#'	轮换文件名称.
			'*'	粘贴板内容 (X11: 主选区) 
			'+'	张贴版内容
			'/'	上一个搜索模式
			':'	上一个命令行命令
			'.'	上一次被插入的文本
							*i_CTRL-R_-*
			'-'	上次轻量删除(少于一行)寄存器. 可通过|.|重复使用
				因为它明白是使用寄存器粘贴而不是插入文本字面量. 
							*i_CTRL-R_=*
			'='	表达式寄存器: Vim会提示输入一个表达式(查阅文档
				|expression|). 注意0x80(数字128)被用于特殊按键. 
				比如可以使用这个移动光标: 
					CTRL-R="\<Up>"
				当结果是列表时, 其中的每一项都将占据一行. 列表
				项的内部也能包含换行符. 
				当结果时浮点数时则会被自动转换为字符串. 
				当append()活着setline()函数被调用时撤销序列将会
				被破坏. 
		查阅关于寄存器的文档|registers|. 

CTRL-R CTRL-R {register}			*i_CTRL-R_CTRL-R*
		插入寄存器的内容. 这和键入单个CTRL-R类似, 但只会插入文本的字面量
		而不会像真正键入那样被解析. 这在寄存器包含像<BS>这样的字符时不同.
		比如:, 包含"abc"的寄存器: >
	CTRL-R a		results in "ac".
	CTRL-R CTRL-R a		results in "ab^Hc".
<		选项'textwidth', 'formatoptions'等仍然会被应用. 如果想要避免这些
		使用CTRL-R CTRL-O, 查看下面的文档. '.'寄存器(上次被插入的文本)
		则仍然会被当作被按键输入的. 
		执行命令之后, '.'寄存器包含将会包含来自寄存器的文本就像通过按键
		键入的. 

CTRL-R CTRL-O {register}			*i_CTRL-R_CTRL-O*
		将寄存器的内容按字面量插入并且取消自动缩进. 这和使用鼠标粘贴文本
		是一样的|<MiddleMouse>|. 当寄存器是行范围的, 这将会将文本插入到
		当前行的上方, 就像"P"一样. '.'寄存器 (上次被插入文本) 仍作为键
		盘输入插入到缓冲区. 
		执行命令之后, '.'寄存器包含键入的命令而不是文本.比如包含字面量
		""而不是来自这个寄存器的文本. 
		这在替换模式中不会替换字符|Replace-mode|! 

CTRL-R CTRL-P {register}			*i_CTRL-R_CTRL-P*
		将寄存器的内容按字面量插入并且修复缩进, 像|[<MiddleMouse>|.
		'.'寄存器 (上次被插入文本) 扔作为键盘输入插入到缓冲区. 
		执行命令之后, '.'寄存器包含键入的命令而不是对应寄存器的文本. 
		比如包含字面量"". 
		这在替换模式中不会替换字符|Replace-mode|! 

						*i_CTRL-T*
CTRL-T		在当前行首插入一个shiftwidth宽度的缩进.缩进总是会对齐'shiftwidth'
		(这是vi兼容的). 
						*i_CTRL-D*
CTRL-D		在当前函授删除一个shiftwidth宽度的缩进.缩进总是会对齐'shiftwidth'
		(这是vi兼容的).
						*i_0_CTRL-D*
0 CTRL-D	将当前行的所有缩进都删除.

						*i_^_CTRL-D*
^ CTRL-D	将当前行的所有缩进都删除. 下一行恢复缩进. 这在插入标签时很有效.

						*i_CTRL-V*
CTRL-V		插入下一个非数字字符字面量. 对于特殊按键则插入终端编码. 键入数字
		八进制或十六进制字符的值也是可行的|i_CTRL-V_digit|.
		CTRL-V之后键入的字符不会应用映射. 
		注意当CTRL-V被映射时(比如用来粘贴文本)可以使用CTRL-Q来代替|i_CTRL-Q|
		当|modifyOtherKeys|启用时特殊转义序列则会被转换为|modifyOtherKeys|
		关闭时的格式, 除非Shift按键被按下了. 

						*i_CTRL-Q*
CTRL-Q		和CTRL-V一致.
		注意: 一些终端连接可能不会响应CTRL-Q. 这在GUI中总是会生效. 

CTRL-SHIFT-V				*i_CTRL-SHIFT-V* *i_CTRL-SHIFT-Q*
CTRL-SHIFT-Q	类似于CTRL-V一样的作用, 如果|modifyOtherKeys|被激活则会插入带有
		modifiers的转义序列按键. 
		注意: 当CTRL-SHIFT-V被系统捕获时 (比如用来粘贴文本) 则可以使用
		CTRL-SHIFT-Q代替.然而,在某些终端中(比如GNOME终端),CTRL-SHIFT-Q
		会在不确认的情况下强制退出终端. 

CTRL-X		进入CTRL-X模式. 这是可以使用命令补全单词或滚动窗口的子模式. 
		查阅文档|i_CTRL-X|及|ins-completion|. 

						*i_CTRL-E*
CTRL-E		将光标下方的字符插入到光标的位置.
						*i_CTRL-Y*
CTRL-Y		将光标上方的字符插入到光标的位置.
		注意对于CTRL-E及CTRL-Y,'textwidth'选项不会被应用以能够从长文本
		行中复制字符. 

						*i_CTRL-_*
CTRL-_		像下面这样切换语言:
		-  当在右左排版语言的窗口中, 启用revins和nohkmap, 因为英语可能
		   会在这种情况被插入. >
			revins: reverse insert mode
			nohkmap: no hebrew keyboard mapping
<		-  当在非右左排版语言的窗口中, revins及hkmap被启用, 因为希伯来
		   语可能在这种情况被插入.

		CTRL-_移动光标到键入文本的末尾. 

		这个命令只会在'allowrevins'选项被启用时有效. 
		请查阅|rileft.txt|获取关于right-to-left模式的更多信息. 
		仅用于编译时带|+rightleft|特性的Vim. 

						*i_CTRL-^*
CTRL-^		切换使用的键入语言字符. 
		当语言|:lmap|映射被定义时: 
		- 如果'iminsert'为1 (langmap映射被使用) 则切换为0
		  (不使用langmap映射) 
		- 如果'iminsert'为其他值时则切换为1, 因此langmap映射被启用. 
		当没有语言映射被定义时: 
		- 如果'iminsert'为2 (使用输入法) 则切换为0 (不适用输入法). 
		- 如果'iminsert'有其他值则切换为2, 因此输入法被启用. 
		当设置为1时,"b:keymap_name"变量的值、'keymap'选项的值或"<lang>"
		会被显示在状态栏中. 语言映射被正常的用来键入与键盘生成所不同的
		字符. 'keymap'选项可以被用来安装它们的所有编号. 

						*i_CTRL-]*
CTRL-]		在不插入字符的情况下触发缩写.

						*i_<Insert>*
<Insert>	切换插入模式和替换模式.
-----------------------------------------------------------------------

						*i_backspacing*
<BS>, CTRL-W及CTRL-U的效果取决于'backspace'选项 (除非'revins'选项被启用). 这是
一个由逗号分隔项组成的列表: 

item	    action ~
indent	    允许退格处理自动缩进
eol	    允许退格处理换行符 (合并后续行)
start	    允许退格处理插入的开始位置; CTRL-W及CTRL-R则会在开始位置停留一次.

当'backspace'选项为空时, Vim会采用Vi兼容的退格方式. 这种情况不能处理自动缩进、
换行符或插入开始位置之前的文本. 

为了向后兼容, 选项也能使用"0", "1", "2"及"3"这些值, 查阅文档|'backspace'|. 

如果'backspace'选项不包含"eol"且光标在第一列, 当上面这三个键名中的一种被使用时, 
当前行会与上一行合并. 这在删除光标前面的<EOL>是高效的. 

						*i_CTRL-V_digit*
在CTRL-V后面输入字符的十进制、八进制或十六进制编码会生成对应的字符. 可以使用这
种方式输入任意字符除了换行符 (<NL>, 十进制值为10). 有5种方式键入字符的编码: 

first char	mode	     max nr of chars   max value ~
(none)		decimal		   3		255
o or O		octal		   3		377	 (255)
x or X		hexadecimal	   2		ff	 (255)
u		hexadecimal	   4		ffff	 (65535)
U		hexadecimal	   8		7fffffff (2147483647)

通常应该键入字符的最大编号的位数. 因此要键入一个空格 (值为32) 应该键入<C-V>032.
可以省略前导0, 这种情况数值之后键入的字符必须是非数值字符.这在其他模式也会发生: 
只要在当前模式键入非法字符,字符前面的值就会被使用并且非法字符则会按一般方式处理.

如果键入了10这个值, 它将会在文件中作为0结束. 10是一个<NL>,内部用来表示<Nul>字符.
当将缓冲区写入到文件时, <NL>字符被转换为<Nul>字符.<NL>字符则在每一行的末尾被写入.
因此如果想要在文件中插入一个<NL>字符则会导致换行. 查阅'fileformat'选项. >
  这里是解释前面为啥不能键入<NL>这个字面量的原因,  这个能是因为文件在读取
  <NL>这个字符就换自动换行, 文件内部特殊的字符应该只有一个换行符,
  至于<EOF>则应该是程序自动判断而非文本内容控制. 
<
						*i_CTRL-X* *insert_expand*
CTRL-X进入可以使用多种命令的子模式. 这些命令的大多数进行关键字补全.
查阅文档|ins-completion|. 

有两个命令被用来向上或向下滚动补全窗口而不用离开插入模式: 

						*i_CTRL-X_CTRL-E*
CTRL-X CTRL-E		将屏幕向上滚动一行。
			补全操作查阅: |complete_CTRL-E|
>
  补全操作时，CTRL-e会阻止补全行为并使用原始输入(CTRL-E的默认行为被阻止了)
<

						*i_CTRL-X_CTRL-Y*
CTRL-X CTRL-Y		将屏幕向下滚动一行。
			补全操作查阅: |complete_CTRL-Y|
>
  补全操作时，CTRL-y会阻止补全行为并使用当前选择的补全(CTRL-Y的默认行为被阻止了)
<

在CTRL-X被按下后, 每一个CTRL-E (CTRL-Y) 将窗口向上(下)滚动一行, 而无需导致光标
从文件的当前位置移动. 一旦其他按键被按下, CTRL-X模式就会退出且被按下的按键被
当作在插入模式中被解释. 


==============================================================================
2. 特殊的特殊按键					*ins-special-special*

下面这些按键是特殊的. 它们会离开插入模式进行其他工作然后再回到插入模式. 这意味
着可以在不离开插入模式进行其他工作. 如果想要一直使用插入模式这将会是非常方便的. 
就像编辑器没有区分普通模式. 可以设置'backspace'选项为"indent,eol,start"并设置
'insertmode'选项. 还可以使用CTRL-O如果想映射功能键到命令的话. 

在这些按键之前或之后的(被插入或被删除的字符)改动能被当都撤销.但只有最后一次改动
能被重做并且总是表象的像"i"命令. 

char		action	~
-----------------------------------------------------------------------
<Up>		cursor one line up			     *i_<Up>*
<Down>		cursor one line down			     *i_<Down>*
CTRL-G <Up>	cursor one line up, insert start column	     *i_CTRL-G_<Up>*
CTRL-G k	cursor one line up, insert start column	     *i_CTRL-G_k*
CTRL-G CTRL-K	cursor one line up, insert start column	     *i_CTRL-G_CTRL-K*
CTRL-G <Down>	cursor one line down, insert start column    *i_CTRL-G_<Down>*
CTRL-G j	cursor one line down, insert start column    *i_CTRL-G_j*
CTRL-G CTRL-J	cursor one line down, insert start column    *i_CTRL-G_CTRL-J*
<Left>		cursor one character left		     *i_<Left>*
<Right>		cursor one character right		     *i_<Right>*
<S-Left>	cursor one word back (like "b" command)	     *i_<S-Left>*
<C-Left>	cursor one word back (like "b" command)	     *i_<C-Left>*
<S-Right>	cursor one word forward (like "w" command)   *i_<S-Right>*
<C-Right>	cursor one word forward (like "w" command)   *i_<C-Right>*
<Home>		cursor to first char in the line	     *i_<Home>*
<End>		cursor to after last char in the line	     *i_<End>*
<C-Home>	cursor to first char in the file	     *i_<C-Home>*
<C-End>		cursor to after last char in the file	     *i_<C-End>*
<LeftMouse>	cursor to position of mouse click	     *i_<LeftMouse>*
<S-Up>		move window one page up			     *i_<S-Up>*
<PageUp>	move window one page up			     *i_<PageUp>*
<S-Down>	move window one page down		     *i_<S-Down>*
<PageDown>	move window one page down		     *i_<PageDown>*
<ScrollWheelDown>    move window three lines down	*i_<ScrollWheelDown>*
<S-ScrollWheelDown>  move window one page down		*i_<S-ScrollWheelDown>*
<ScrollWheelUp>      move window three lines up		*i_<ScrollWheelUp>*
<S-ScrollWheelUp>    move window one page up		*i_<S-ScrollWheelUp>*
<ScrollWheelLeft>    move window six columns left	*i_<ScrollWheelLeft>*
<S-ScrollWheelLeft>  move window one page left		*i_<S-ScrollWheelLeft>*
<ScrollWheelRight>   move window six columns right	*i_<ScrollWheelRight>*
<S-ScrollWheelRight> move window one page right		*i_<S-ScrollWheelRight>*
CTRL-O		execute one command, return to Insert mode   *i_CTRL-O*
CTRL-\ CTRL-O	like CTRL-O but don't move the cursor	     *i_CTRL-\_CTRL-O*
CTRL-L		when 'insertmode' is set: go to Normal mode  *i_CTRL-L*
CTRL-G u	close undo sequence, start new change	     *i_CTRL-G_u*
CTRL-G U	don't start a new undo block with the next   *i_CTRL-G_U*
		left/right cursor movement, if the cursor
		stays within the same line
-----------------------------------------------------------------------

注意: 如果方向键退出了插入模式, 请检查'noesckeys'选项. Vim使用cursor keys指代
方向键, 但实际上更通用的叫法是Arrow keys. 

CTRL-O命令有时会有副作用: 如果光标在行尾之外, 命令会将光标置于行尾最后一个字符
在映射中通常使用<Esc>会更好 (首先放置一个"x"在文本中, <Esc>之后总是会将光标置于
其上[这里指的应该是<Esc>会退出插入模式并把光标放在插入模式光标前一个字符上]).
或者使用CTRL-\ CTRL-O, 但要意识到光标可能会超出行尾. 注意CTRL-\ CTRL-O之后的命令
仍可以移动光标, 光标的位置不会恢复为它原先的位置. 

CTRL-O命令会切换到普通模式. 如果再用命令进入插入模式它通常是不会嵌套的. 因此当
键入"a<C-O>a"之后按<Esc>回到普通模式, 这不需要按两次<Esc>键. 一个例外是当没有键
入命令时, 比如执行一个映射或引入一个脚本. 短暂的切换到插入模式才能让映射生效. 

修饰键Shift+方向键并不是在所有的终端上都能生效. 

另一个副作用就是在"i"或者"a"命令前面指定计数会被忽略. 这是因为重复CTRL-O之后的
命令效果太复杂了. 

一个使用CTRL-G u的例子: >

	:inoremap <C-H> <C-G>u<C-H>

这重定义了退格键开启新的撤销序列.现在使用CTRL-O u可以撤销退格键的操作而不用改动
之前键入内容. 另一个例子: >

	:inoremap <CR> <C-]><C-G>u<CR>

这在每一个换行符处开启了心的撤销块. 它也会扩展之前的缩写. 

一个使用CTRL-G U的例子: >

	inoremap <Left>  <C-G>U<Left>
	inoremap <Right> <C-G>U<Right>
	inoremap <expr> <Home> col('.') == match(getline('.'), '\S') + 1 ?
	 \ repeat('<C-G>U<Left>', col('.') - 1) :
	 \ (col('.') < match(getline('.'), '\S') ?
	 \     repeat('<C-G>U<Right>', match(getline('.'), '\S') + 0) :
	 \     repeat('<C-G>U<Left>', col('.') - 1 - match(getline('.'), '\S')))
	inoremap <expr> <End> repeat('<C-G>U<Right>', col('$') - col('.'))
	inoremap ( ()<C-G>U<Left>

这使得在插入模式使用方向键不开启新撤销块得以实现且因此使用|.|(redo)也会按预期
生效. 此外键入像上面那样使用"("映射键入(: 

   Lorem ipsum (dolor

将可以通过|.|命令按预期重复输入

   Lorem ipsum (dolor)

使用CTRL-O会分隔撤销块: 在这之前或之后键入的文本将会被分别撤销. 如果像要避免这样
(比如在映射中)则可能需要使用CTRL-R = |i_CTRL-R|. 比如, 调用一个函数: >
	:imap <F2> <C-R>=MyFunc()<CR>

当'whichwrap'选项被恰当的设置, 在行首/尾字符使用<Left>/<Right>将会使光标跳转到
上/下一行. 

CTRL-G j及CTRL-G k命令可以被用来在一列的前面插入文本. 比如: >
   int i;
   int j;
将光标的位置移动到第一个"int", 键入 "istatic <C-G>j       ". 结果将会变为: >
   static int i;
	  int j;
可以使用可是快级别命令"I"在每一行的同一列前面插入同样的文本	|v_b_I|

==============================================================================
3. 'textwidth' 及 'wrapmargin' 选项			*ins-textwidth*

'textwidth'选项可以被用来在行内容过长时自动打断行. 设置'textwidth'选项为想要的
最大行长度. 如果键入了过多字符 (非空格或制表符) , 最后一个单词将会被放到新行. 
(除非这个单词是当前行的唯一一个单词, 如汉语). 如果设置'textwidth'为0, 这个特性
将会被禁用. 

'wrapmargin'选项做几乎同样的事. 差异之处在于'textwidth'有固定的宽度而'wrapmargin'
取决于屏幕的宽度. 当使用'wrapmargin'时, 这就等同于使用'textwidth'设置值为(columns - 
'wrapmargin'), 这里的columns是屏幕的宽度. 

当'textwidth'及'wrapmargin'同时被设置时, 优先使用'textwidth'.

如果不想打断行但又想在合适的地方折行, 查阅'linebreak'选项. 

行内容只会在使用插入模式时或合并后续行时被自动打断. 当在替换模式且行长度没被改动
行内容将不会被打断. 

长内容行会在外边距之后键入非空白字符时被打断. 行内容应该被打断的状况可以通过向
'formatoptions'选项添加字符进行限制: 
"l"  只会在开始插入时打断短于'textwidth'的行.
"v"  只会在当前插入命令期间在被输入空白字符的位置打断. 这通常是Vi兼容的. 
"lv" 只会在开始插入时打断短于'textwidth'的行且在插入命令期间在被输入空白字符的
     的位置打断. 只在跨越'textwidth'边界时键入非空白字符与"l"不同.

通常来说内部函数会被用来决定怎么打断行内容. 如果想要设置不同的打断方式, 可以设置
'formatexpr'选项为一个关注换行的表达式. 

如果想要格式化文本块, 可以适用操作符"gq". 键入"gq"及一个移动命令将光标移动到块的
末尾. 在多数情况下, "gq}"命令会实现想要的操作 (格式化至当前段落末尾). 同样的,
可以适用"gqap"格式化整个段落而不管光标当前的位置在哪. 活着可以使用可视模式: 
按下"v"键, 移动到块的末尾然后按下"gq". 查阅文档|gq|. 

==============================================================================
4. 'expandtab', 'smarttab' 及 'softtabstop' 选项	*ins-expandtab*

如果'expandtab'选项被启用, 空格将会被用来填充制表符指定数量的空白. 如果想要输入
真的<Tab>, 先按下CTRL-V (当CTRL-V被映射时使用CTRL-Q |i_CTRL-Q|).
'expandtab'选项默认是关闭的. 注意在替换模式中, 单个字符将会被多个空格替换. 这样
的结果就是行内的字符数量增加了. 退格键一次会删除一个空格. 原来的字符将会被放置
回退格键扫过的范围(一次只会恢复一个原来的字符).

							*ins-smarttab*
当'smarttab'选项被启用时, 按一次<Tab>按键会在行首位置插入'shiftwidth'占位而在其
它位置插入'tabstop'占位. 这意味着多空格被用来代替<Tab>被插入. 当'smarttab'关闭时
<Tab>总是会插入'tabstop'个占位且'shiftwidth'只会用于">>"及类似的命令. >
  这里的描述并不完全正确, 各选项的全部作用请查阅各自选项的文档.
<
							*ins-softtabstop*
当'softtabstop'选项是非零值, <Tab>插入'softtabstop'个位置且用于删除空格的<BS>会
删除'softtabstop'个位置. 这就像'tabstop'被设置为'softtabstop', 但真实的<Tab>仍
占用'tabstop'个位置, 因此文件被其他应用使用时看起来仍是正确的. 

如果'softtabstop'是非零值,<BS>将会尝试删除同样多的空格已移动到上一个'softtabstop'
的位置, 如果上一个被插入的字符是空格则仅删除光标前面的单个字符. 否则将不能将不能
删除光标前面的单个字符. 这首先会删除'softtabstop'个字符然后键入额外的空格让光标
位于期望的位置. 

==============================================================================
5. 替换模式				*Replace* *Replace-mode* *mode-replace*

在普通模式中输入"R"命令进入替换模式. 

在替换模式中, 每个键入的字符都将会替换当前行光标位置的字符. 如果没有要被替换的
字符 (在行尾时), 键入的字符将会添加到行尾 (就像插入模式一样).因此行内的字符数量
会保持一致直到触及行尾. 如果键入<NL>, 则会插入一个换行符且不会删除字符. 

小心<Tab>字符. 如果在它的地方键入普通的打印字符, 则字符的数量保持不变但列数量则
会减小. 

如果在替换模式中删除字符 (使用<BS>, CTRL-W或CTRL-U), 最终结果就是删除之前做出的
替换改动. 之前被替换的字符会被恢复. 如果键入超过已经存在的文本, 则之前添加的
字符会被删除. 这实际上是a-character-at-a-time撤销命令.

如果'expandtab'选项被启用, <Tab>将会替换用多个空格替换单个字符. 这样的结果就是
行内字符数量增加了. 退格会一次会删除一个空格. 并恢复这个空格扫过的原来的字符
(最后一个字符).

==============================================================================
6. 虚拟替换模式				*vreplace-mode* *Virtual-Replace-mode*

在普通模式使用"gR"命令进入虚拟替换模式.  {当编译不带|+vreplace|特性时则不可用}

虚拟替换模式和替换模式相似, 但不会替换文件中真实字符而是替换屏幕真实的区域,因此
文件中其余字符的不会被移动. 

如果键入<Tab>则可能替换多个普通字符, 如果在<Tab>位置键入普通字母则可能键入失败,
因为<Tab>仍会像之前一样占据同样的位置. 

键入<NL>也不会导致文件中后续的字符被移动. 当前行的剩余内容会被<NL>替换 (也就是
光标之后的内容会被删除), 并且替换会在下一行继续进行. 新行并不会被插入除非到了
文件的末尾. 

插入效果可以通过使用CTRL-T及CTRL-D查看. 光标之前的字符会被正常的缩进到一边, 但
行内之后的字符则保持不变. CTRL-T会隐藏旧内容处被缩进的字符, 但CTRL-D则会重新
显示它们. >
  实测在虚拟替换模式中更多的类似插入模式的<Del>的正向和反向操作. 

如替换模式, 使用<BS>等按键会恢复之前被替换的字符. 这在用'smartindent'、CTRL-T及
CTRL-D, 'expandtab', 'smarttab', 'softtabstop'等连字符中也能生效.

在'list'模式, 虚拟替换模式就像不在'list'模式一样,除非在'cpoptions'中设置"L"字符

注意光标之外的字符被移动的唯一情况就是在'list'模式|'list'|, 并恰巧'wrap'选项被
启用 (这样行长度变得比屏幕的宽度更宽或更短). 其他情况下空格可能被插入以避免后续
字符被移动. 

这个模式编辑表格中<Tab>分隔的列是很有效的, 因为这会在键入新数据时保持其他列对齐. 

==============================================================================
7. 插入模式补全						*ins-completion*

在插入模式和替换模式中，有许多命令用于补全被键入的关键字或行内容。当使用复杂的
关键字时这是非常有效的（例如：带有大写字母及下划线的函数名称）

可以用下列命令完成各种补全:

1. 整行补全						|i_CTRL-X_CTRL-L|
2. 当前文件关键字补全					|i_CTRL-X_CTRL-N|
3. 'dictionary'字典关键字				|i_CTRL-X_CTRL-K|
4. 'thesaurus'同义词关键字，同义词样式			|i_CTRL-X_CTRL-T|
5. 当前及导入文件的关键字				|i_CTRL-X_CTRL-I|
6. 标签							|i_CTRL-X_CTRL-]|
7. 文件名						|i_CTRL-X_CTRL-F|
8. 定义或宏						|i_CTRL-X_CTRL-D|
9. Vim命令行						|i_CTRL-X_CTRL-V|
10. 用户定义补全					|i_CTRL-X_CTRL-U|
11. omni completion					|i_CTRL-X_CTRL-O|
12. 拼写建议						|i_CTRL-X_s|
13. 'complete'选项设置关键字查找			|i_CTRL-N| |i_CTRL-P|
>
  3,4	侧重点不同，3侧重字典补全即补全内容, 4侧重同义字补全
  13	这个选项设置了很多内容以支持补全，功能很强大
  12	听说是个很神奇的补全 |omnifunc| |complete-functions|
<

另外, |i_CTRL-X_CTRL-Z|会在不改动文本的情况下停止补全. >
  这里应该是指在按下CTRL-X之后会进入补全模式选择状态, 这时可以通过按CTRL-Z退出
  这个状态. 按其他键会在离开这个状态并键入按下的按键. 

所有命令除了CTRL-N及CTRL-P都在CTRL-X模式被执行. 这是插入模式和替换模式的子模式. 
通过键入CTRL-X及一个CTRL-X命令进入CTRL-X模式. 通过键入CTRL-X模式的非法命令离开
CTRL-X模式. 有效按键是CTRL-X命令本身, CTRL-N (下一个)及CTRL-P (上一个). >
  这里有三个概念, 键入CTRL-X指在键盘上键入CTRL-X组合键
		  CTRL-X命令指上文提到的那些命令
		  CTRL-X模式指补全模式, 按下CTRL-X命令之后会弹出补全窗口

可以使用|complete_info()|获取当前补全信息. 如果想要调整匹配的内容可以查阅
'infercase'选项. 

当插入一个从|popup-menu|中选择的候选词, 列表中候选词不匹配的部分会被使用
|hl-ComplMatchIns|高亮.如果在'completeopt'选项中启用了模糊搜索(fuzzy)则不会高亮

							*complete_CTRL-E*
当补全窗口被激活后可以使用CTRL-E停止补全并恢复原来键入的文本. CTRL-E不会被插入. 

							*complete_CTRL-Y*
当补全弹窗菜单被显示时可以使用CTRL-Y停止补全并接受当前选择入口.CTRL-Y不会被插入.
键入空格, 回车或一些其他不可打印字符将会离开补全模式并插入键入的字符. 

当弹出菜单被显示时存在一些特殊按键, 查阅文档|popupmenu-keys|. 

注意: CTRL-X模式中合法的按键不会被映射. 这允许`:map <C-F> <C-X><C-F>`映射生效. 
(假定"<"不在'cpo'选项中启用). 结束CTRL-X模式的按键(任意非法CTRL-X模式命令按键)
会被映射. 此外, 当使用'complete'进行补全时映射会正常被应用. 

								*E565*
注意: 当补全被激活时插入模式不能被递归使用且缓冲区的文本不能被改动.
调用":normal i .."的映射会生成E565错误.

建议使用下面映射让键入补全命令更轻松 (尽管这会隐藏其他命令; 这要求'cpo'选项
不包"<"): >
    :inoremap <C-]> <C-X><C-]>
    :inoremap <C-F> <C-X><C-F>
    :inoremap <C-D> <C-X><C-D>
    :inoremap <C-L> <C-X><C-L>

键入CTRL-R将寄存器内容插入不会离开CTRL-X模式,这是一个特殊情况(查阅|i_CTRL-R|命令) 
这主要目的是允许使用'='寄存器调用一些函数确认下个操作符. 如果寄存器的内容
(或执行'='寄存器表达式的结果) 不是有效的CTRL-X模式按键则会导致退出CTRL-X模式
就像这些按键被键入那样. 

比如,下面脚本会在当前行当前只有空格字符时将<Tab>映射一个真正的<Tab>插入或开始/
继续CTRL-N补全操作: >

	function! CleverTab()
	   if strpart( getline('.'), 0, col('.')-1 ) =~ '^\s*$'
	      return "\<Tab>"
	   else
	      return "\<C-N>"
	   endif
	endfunction
	inoremap <Tab> <C-R>=CleverTab()<CR>


补全整行						*compl-whole-line*

							*i_CTRL-X_CTRL-L*
CTRL-X CTRL-L		向后搜索以当前行同样字符开始的文本行. 缩进会被忽略.匹配
			的行会被插入到光标之前. 
			'complete'选项被用来确定哪个缓冲区的内容被用来搜索匹配项.
			被加载或被卸载的缓冲区都会被使用. 
	CTRL-L	或
	CTRL-P		向后搜索下一个匹配行. 搜索到的文本行会替换上一个匹配行. 

	CTRL-N		向前搜索下个匹配行. 搜索到的文本行会替换上一个匹配行.

	CTRL-X CTRL-L	在扩展一行内容后可以通过键入CTRL-X CTRL-L再次获取额外的
			下一行. 除非键入两次CTRL-X. 这只对加载的缓冲区有效. 

补全当前文件中的关键字			*compl-current*

							*i_CTRL-X_CTRL-P*
							*i_CTRL-X_CTRL-N*
CTRL-X CTRL-N		向前搜索以光标之前关键字开始的单词.被找到的关键字会被
			插入到光标之前.

CTRL-X CTRL-P		向后所有以光标之前关键字开始的单词.被找到的关键字会被
			插入到光标之前.

	CTRL-N		向前搜索下一个匹配的关键字.关键字会替换上个匹配的关键字

	CTRL-P		向后索索下一个匹配的关键字.关键字会替换上个匹配的关键字

	CTRL-X CTRL-N 或
	CTRL-X CTRL-P	进一步使用CTRL-X CTRL-N或CTRL-X CTRL-P会复制在其他上下
			文中上次扩展的单词除非键入CTRL-X两次. 

如果在光标之前存在关键字 (不在字母表或不在'iskeyword'选项中的名称), 它会在添加
"\<"前缀后被用做搜索模式 (意思是: 单词的开始), 否则"\<\k\k"被当作搜索模式
(任意以最少两个字符开始的关键字). 

在替换模式中, 被替换字符的数量取决于匹配到的字符串的长度. 这就像将匹配到的字符串
在替换模式中键入. 

如果光标之前没有有效的关键字, 任意至少两个字符的关键字都会被匹配. 
	比如, 要获取: 
	    printf("(%g, %g, %g)", vector[0], vector[1], vector[2]);
	只需要键入: 
	    printf("(%g, %g, %g)", vector[0], ^P[1], ^P[2]);

搜索会在文件内循环进行, 'wrapscan'选项的值不会被应用. 

多次重复的相同补全会被跳过; 因此不同的匹配内容会在按下每个CTRL-N及CTRL-P键时被
插入 (除非仅有一个匹配关键字). 

单个字符匹配不会被包含在内, 因为它们通常妨碍真正要补全的内容. 
	比如, 要获得: 
		printf("name = %s\n", name);
	只需要键入: 
		printf("name = %s\n", n^P);
	或甚至键入:
		printf("name = %s\n", ^P);
'\n'中的'n'被跳过. 

在扩展单词之后, 可以使用CTRL-X CTRL-P或CTRL-X CTRL-N以获取在其他上下文中跟在
扩展内容之后的单词. 这些序列搜索被扩展的文本及通过获取额外单词进一步扩展. 这在
需要重复一个复杂单词序列时是很有用的. 尽管CTRL-P及CTRL-N只查找至少包含两个字符
的字符串, CTRL-X CTRL-P及CTRL-X CTRL-N可以被用来扩展只有一个字符的单词. 
	比如, 要获取: 
		M&eacute;xico
	可以键入: 
		M^N^P^X^P^X^P

CTRL-N开始扩展然后CTRL-P恢复单个字符"M",下两组按键CTRL-X CTRL-P补全单词"&eacute"
及";xico".

如果前一个扩展被分隔, 因为扩展比'textwidth'要长, 之后只有当前行的文本会被使用. 

如果被找到的匹配内容是在行尾, 那么下一行的首个单词将会被插入并且发送一条"word 
from other line"信息显示, 如果这个单词被接受下一个CTRL-X CTRL-P或CTRL-X CTRL-N
将会搜索以这个单词开始的文本行. 


补全'dictionary'选项中的关键字				*compl-dictionary*

							*i_CTRL-X_CTRL-K*
CTRL-X CTRL-K		在'dictionary'选项指定的文件中搜索以光标位置内容开始的
			单词. 这与CTRL-N类似, 但只会搜索字典文件的内容而不会搜
			索当前文件的内容. 被找到的关键字会被插入到光标前面. 这
			可能会相当慢因为在使用找到的匹配项之前需要查找所有的匹
			配项. 'dictionary'选项默认是空的. 
			对于在哪查找建议的单词列表, 查阅'dictionary'选项. 
			补全会应用'ignorecase', 'smartcase',及'infercase'选项. 

	CTRL-K	或
	CTRL-N		向下搜索下一个匹配的关键字. 这个关键字会替换掉前一个
			匹配的关键字.

	CTRL-P		向上搜索下一个匹配的关键字. 这个关键字会替换掉前一个
			匹配的关键字.


补全'thesaurus'(同义词)的单词					*compl-thesaurus*

							*i_CTRL-X_CTRL-T*
CTRL-X CTRL-T		与CTRL-X CTRL-K效果类似但以一种特殊的方式. 命令使用
			'thesaurus'选项代替'dictionary'. 如果在同义词文件中找到
			匹配项, 同一行的剩余单词都被被作为匹配项, 即便它们不会
			补全这个单词. 因此当前要输入的单词可能会被完全替换. 

	CTRL-T	或
	CTRL-N		向下搜索下一个匹配的关键字. 这个关键字会替换掉前一个
			匹配的关键字.

	CTRL-P		向上搜索下一个匹配的关键字. 这个关键字会替换掉前一个
			匹配的关键字.

在被'thesaurus'选项指定的文件中每一行应该包含相同意思的单词并以非关键字符分隔
(推荐使用空格). 每一行最大长度为510字节. 

比如, 'thesaurus'选项指定了一个文件包如下行内容: >
	angry furious mad enraged
将光标放置在"ang"字母后面并键入CTRL-X CTRL-T将会补全单词"angry"; 继续键入按键则
会将补全的单词改为"furious", "mad"等. 

另一种用法是包含两种语言的翻译, 或通过关键字为函数API分组. 

下面这个issue包含一个英语单词列表: 
https://github.com/vim/vim/issues/629#issuecomment-443293282
解压thesaurus_pkg.zip包, 将thesaurus.txt文件放到'thesaurus'选项指定的位置, 如: 
~/.vim/thesaurus/english.txt.


用'thesaurusfunc'补全关键字			*compl-thesaurusfunc*

如果设置了'thesaurusfunc'选项, 则用户指定指定的函数会被用来
If the 'thesaurusfunc' option is set, then the user specified function is
invoked to get the list of completion matches and the 'thesaurus' option is
not used. See |complete-functions| for an explanation of how the function is
invoked and what it should return.

Here is an example that uses the "aiksaurus" command (provided by Magnus
Groß): >

    func Thesaur(findstart, base)
      if a:findstart
	return searchpos('\<', 'bnW', line('.'))[1] - 1
      endif
      let res = []
      let h = ''
      for l in systemlist('aiksaurus ' .. shellescape(a:base))
	if l[:3] == '=== '
	  let h = '(' .. substitute(l[4:], ' =*$', ')', '')
	elseif l ==# 'Alphabetically similar known words are: '
	  let h = "\U0001f52e"
	elseif l[0] =~ '\a' || (h ==# "\U0001f52e" && l[0] ==# "\t")
	  call extend(res, map(split(substitute(l, '^\t', '', ''), ', '), {_, val -> {'word': val, 'menu': h}}))
	endif
      endfor
      return res
    endfunc

    if exists('+thesaurusfunc')
      set thesaurusfunc=Thesaur
    endif


Completing keywords in the current and included files	*compl-keyword*

The 'include' option is used to specify a line that contains an include file
name.  The 'path' option is used to search for include files.

							*i_CTRL-X_CTRL-I*
CTRL-X CTRL-I		Search for the first keyword in the current and
			included files that starts with the same characters
			as those before the cursor.  The matched keyword is
			inserted in front of the cursor.

	CTRL-N		Search forwards for next matching keyword.  This
			keyword replaces the previous matching keyword.
			Note: CTRL-I is the same as <Tab>, which is likely to
			be typed after a successful completion, therefore
			CTRL-I is not used for searching for the next match.

	CTRL-P		Search backward for previous matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-X CTRL-I	Further use of CTRL-X CTRL-I will copy the words
			following the previous expansion in other contexts
			unless a double CTRL-X is used.

Completing tags						*compl-tag*
							*i_CTRL-X_CTRL-]*
CTRL-X CTRL-]		Search for the first tag that starts with the same
			characters as before the cursor.  The matching tag is
			inserted in front of the cursor.  Alphabetic
			characters and characters in 'iskeyword' are used
			to decide which characters are included in the tag
			name (same as for a keyword).  See also |CTRL-]|.
			The 'showfulltag' option can be used to add context
			from around the tag definition.
	CTRL-]	or
	CTRL-N		Search forwards for next matching tag.  This tag
			replaces the previous matching tag.

	CTRL-P		Search backward for previous matching tag.  This tag
			replaces the previous matching tag.


Completing file names					*compl-filename*
							*i_CTRL-X_CTRL-F*
CTRL-X CTRL-F		Search for the first file name that starts with the
			same characters as before the cursor.  The matching
			file name is inserted in front of the cursor.
			Alphabetic characters and characters in 'isfname'
			are used to decide which characters are included in
			the file name.  Note: the 'path' option is not used
			here (yet).
	CTRL-F	or
	CTRL-N		Search forwards for next matching file name.  This
			file name replaces the previous matching file name.

	CTRL-P		Search backward for previous matching file name.
			This file name replaces the previous matching file
			name.


Completing definitions or macros			*compl-define*

The 'define' option is used to specify a line that contains a definition.
The 'include' option is used to specify a line that contains an include file
name.  The 'path' option is used to search for include files.

							*i_CTRL-X_CTRL-D*
CTRL-X CTRL-D		Search in the current and included files for the
			first definition (or macro) name that starts with
			the same characters as before the cursor.  The found
			definition name is inserted in front of the cursor.
	CTRL-D	or
	CTRL-N		Search forwards for next matching macro name.  This
			macro name replaces the previous matching macro
			name.

	CTRL-P		Search backward for previous matching macro name.
			This macro name replaces the previous matching macro
			name.

	CTRL-X CTRL-D	Further use of CTRL-X CTRL-D will copy the words
			following the previous expansion in other contexts
			unless a double CTRL-X is used.


Completing Vim commands					*compl-vim*

Completion is context-sensitive.  It works like on the Command-line.  It
completes an Ex command as well as its arguments.  This is useful when writing
a Vim script.

							*i_CTRL-X_CTRL-V*
CTRL-X CTRL-V		Guess what kind of item is in front of the cursor and
			find the first match for it.
			Note: When CTRL-V is mapped you can often use CTRL-Q
			instead of |i_CTRL-Q|.
	CTRL-V	or
	CTRL-N		Search forwards for next match.  This match replaces
			the previous one.

	CTRL-P		Search backwards for previous match.  This match
			replaces the previous one.

	CTRL-X CTRL-V	Further use of CTRL-X CTRL-V will do the same as
			CTRL-V.  This allows mapping a key to do Vim command
			completion, for example: >
				:imap <Tab> <C-X><C-V>

User defined completion					*compl-function*

Completion is done by a function that can be defined by the user with the
'completefunc' option.  See below for how the function is called and an
example |complete-functions|.

							*i_CTRL-X_CTRL-U*
CTRL-X CTRL-U		Guess what kind of item is in front of the cursor and
			find the first match for it.
	CTRL-U	or
	CTRL-N		Use the next match.  This match replaces the previous
			one.

	CTRL-P		Use the previous match.  This match replaces the
			previous one.


Omni completion						*compl-omni*

Completion is done by a function that can be defined by the user with the
'omnifunc' option.  This is to be used for filetype-specific completion.

See below for how the function is called and an example |complete-functions|.
For remarks about specific filetypes see |compl-omni-filetypes|.
More completion scripts will appear, check www.vim.org.  Currently there is a
first version for C++.

							*i_CTRL-X_CTRL-O*
CTRL-X CTRL-O		Guess what kind of item is in front of the cursor and
			find the first match for it.
	CTRL-O	or
	CTRL-N		Use the next match.  This match replaces the previous
			one.

	CTRL-P		Use the previous match.  This match replaces the
			previous one.


Spelling suggestions					*compl-spelling*

A word before or at the cursor is located and correctly spelled words are
suggested to replace it.  If there is a badly spelled word in the line, before
or under the cursor, the cursor is moved to after it.  Otherwise the word just
before the cursor is used for suggestions, even though it isn't badly spelled.

NOTE: CTRL-S suspends display in many Unix terminals.  Use 's' instead.  Type
CTRL-Q to resume displaying.

						*i_CTRL-X_CTRL-S* *i_CTRL-X_s*
CTRL-X CTRL-S   or
CTRL-X s		Locate the word in front of the cursor and find the
			first spell suggestion for it.
	CTRL-S	or
	CTRL-N		Use the next suggestion.  This replaces the previous
			one.  Note that you can't use 's' here.

	CTRL-P		Use the previous suggestion.  This replaces the
			previous one.


Completing keywords from different sources		*compl-generic*

							*i_CTRL-N*
CTRL-N			Find next match for words that start with the
			keyword in front of the cursor, looking in places
			specified with the 'complete' option.  The found
			keyword is inserted in front of the cursor.

							*i_CTRL-P*
CTRL-P			Find previous match for words that start with the
			keyword in front of the cursor, looking in places
			specified with the 'complete' option.  The found
			keyword is inserted in front of the cursor.

	CTRL-N		Search forward for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-P		Search backwards for next matching keyword.  This
			keyword replaces the previous matching keyword.

	CTRL-X CTRL-N or
	CTRL-X CTRL-P	Further use of CTRL-X CTRL-N or CTRL-X CTRL-P will
			copy the words following the previous expansion in
			other contexts unless a double CTRL-X is used.


Stop completion						*compl-stop*

							*i_CTRL-X_CTRL-Z*
CTRL-X CTRL-Z		Stop completion without changing the text.


FUNCTIONS FOR FINDING COMPLETIONS			*complete-functions*

This applies to 'completefunc', 'thesaurusfunc' and 'omnifunc'.

The function is called in two different ways:
- First the function is called to find the start of the text to be completed.
- Later the function is called to actually find the matches.

On the first invocation the arguments are:
   a:findstart  1
   a:base	empty

The function must return the column where the completion starts.  It must be a
number between zero and the cursor column "col('.')".  This involves looking
at the characters just before the cursor and including those characters that
could be part of the completed item.  The text between this column and the
cursor column will be replaced with the matches.  If the returned value is
larger than the cursor column, the cursor column is used.

Negative return values:
   -2	To cancel silently and stay in completion mode.
   -3	To cancel silently and leave completion mode.
   Another negative value: completion starts at the cursor column

On the second invocation the arguments are:
   a:findstart  0
   a:base	the text with which matches should match; the text that was
		located in the first call (can be empty)

The function must return a List with the matching words.  These matches
usually include the "a:base" text.  When there are no matches return an empty
List.  Note that the cursor may have moved since the first invocation, the
text may have been changed.

In order to return more information than the matching words, return a Dict
that contains the List.  The Dict can have these items:
	words		The List of matching words (mandatory).
	refresh		A string to control re-invocation of the function
			(optional).
			The only value currently recognized is "always", the
			effect is that the function is called whenever the
			leading text is changed.

If you want to suppress the warning message for an empty result, return
|v:none|.  This is useful to implement asynchronous completion with
|complete()|.

Other items are ignored.

For acting upon end of completion, see the |CompleteDonePre| and
|CompleteDone| autocommand event.

For example, the function can contain this: >
	let matches = ... list of words ...
	return {'words': matches, 'refresh': 'always'}
<
If looking for matches is time-consuming, |complete_check()| may be used to
maintain responsiveness.

						*complete-items*
Each list item can either be a string or a Dictionary.  When it is a string it
is used as the completion.  When it is a Dictionary it can contain these
items:
	word		the text that will be inserted, mandatory
	abbr		abbreviation of "word"; when not empty it is used in
			the menu instead of "word"
	menu		extra text for the popup menu, displayed after "word"
			or "abbr"
	info		more information about the item, can be displayed in a
			preview or popup window
	kind		single letter indicating the type of completion
	icase		when non-zero case is to be ignored when comparing
			items to be equal; when omitted zero is used, thus
			items that only differ in case are added
	equal		when non-zero, always treat this item to be equal when
			comparing. Which means, "equal=1" disables filtering
			of this item.
	dup		when non-zero this match will be added even when an
			item with the same word is already present.
	empty		when non-zero this match will be added even when it is
			an empty string
	user_data	custom data which is associated with the item and
			available in |v:completed_item|; it can be any type;
			defaults to an empty string
	abbr_hlgroup	an additional highlight group whose attributes are
			combined with |hl-PmenuSel| and |hl-Pmenu| or
			|hl-PmenuMatchSel| and |hl-PmenuMatch| highlight
			attributes in the popup menu to apply cterm and gui
			properties (with higher priority) like strikethrough
			to the completion items abbreviation
	kind_hlgroup	an additional highlight group specifically for setting
			the highlight attributes of the completion kind. When
			this field is present, it will override the
			|hl-PmenuKind| highlight group, allowing for the
			customization of ctermfg and guifg properties for the
			completion kind
	match		See "matches" in |complete_info()|.

All of these except "icase", "equal", "dup" and "empty" must be a string.  If
an item does not meet these requirements then an error message is given and
further items in the list are not used.  You can mix string and Dictionary
items in the returned list.

The "menu" item is used in the popup menu and may be truncated, thus it should
be relatively short.  The "info" item can be longer, it will  be displayed in
the preview window when "preview" appears in 'completeopt' or in a popup
window when "popup" appears in 'completeopt'.  In the preview window the
"info" item will also remain displayed after the popup menu has been removed.
This is useful for function arguments.  Use a single space for "info" to
remove existing text in the preview window.  The size of the preview window is
three lines, but 'previewheight' is used when it has a value of 1 or 2.

						*complete-popup*
When "popup" is in 'completeopt' a popup window is used to display the "info".
Then the 'completepopup' option specifies the properties of the popup.  This
is used when the info popup is created.  The option is a comma-separated list
of values:
	height		maximum height of the popup
	width		maximum width of the popup
	highlight	highlight group of the popup (default is PmenuSel)
	align		"item" (default) or "menu"
	border		"on" (default) or "off"
Example: >
	:set completepopup=height:10,width:60,highlight:InfoPopup

When the "align" value is "item" then the popup is positioned close to the
selected item.  Changing the selection will also move the popup.  When "align"
is "menu" then the popup is aligned with the top of the menu if the menu is
below the text, and the bottom of the menu otherwise.

After the info popup is created it can be found with |popup_findinfo()| and
properties can be changed with |popup_setoptions()|.

						*complete-popuphidden*
If the information for the popup is obtained asynchronously, use "popuphidden"
in 'completeopt'.  The info popup will then be initially hidden and
|popup_show()| must be called once it has been filled with the info.  This can
be done with a |CompleteChanged| autocommand, something like this: >
	set completeopt+=popuphidden
	au CompleteChanged * call UpdateCompleteInfo()
	func UpdateCompleteInfo()
	  " Cancel any pending info fetch
	  let item = v:event.completed_item
	  " Start fetching info for the item then call ShowCompleteInfo(info)
	endfunc
	func ShowCompleteInfo(info)
	  let id = popup_findinfo()
	  if id
	    call popup_settext(id, 'async info: ' .. a:info)
	    call popup_show(id)
	  endif
	endfunc

<						*complete-item-kind*
The "kind" item uses a single letter to indicate the kind of completion.  This
may be used to show the completion differently (different color or icon).
Currently these types can be used:
	v	variable
	f	function or method
	m	member of a struct or class
	t	typedef
	d	#define or macro

When searching for matches takes some time call |complete_add()| to add each
match to the total list.  These matches should then not appear in the returned
list!  Call |complete_check()| now and then to allow the user to press a key
while still searching for matches.  Stop searching when it returns non-zero.

							*E840*
The function is allowed to move the cursor, it is restored afterwards.
The function is not allowed to move to another window or delete text.

An example that completes the names of the months: >
	fun! CompleteMonths(findstart, base)
	  if a:findstart
	    " locate the start of the word
	    let line = getline('.')
	    let start = col('.') - 1
	    while start > 0 && line[start - 1] =~ '\a'
	      let start -= 1
	    endwhile
	    return start
	  else
	    " find months matching with "a:base"
	    let res = []
	    for m in split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec")
	      if m =~ '^' .. a:base
		call add(res, m)
	      endif
	    endfor
	    return res
	  endif
	endfun
	set completefunc=CompleteMonths
<
The same, but now pretending searching for matches is slow: >
	fun! CompleteMonths(findstart, base)
	  if a:findstart
	    " locate the start of the word
	    let line = getline('.')
	    let start = col('.') - 1
	    while start > 0 && line[start - 1] =~ '\a'
	      let start -= 1
	    endwhile
	    return start
	  else
	    " find months matching with "a:base"
	    for m in split("Jan Feb Mar Apr May Jun Jul Aug Sep Oct Nov Dec")
	      if m =~ '^' .. a:base
		call complete_add(m)
	      endif
	      sleep 300m	" simulate searching for next match
	      if complete_check()
		break
	      endif
	    endfor
	    return []
	  endif
	endfun
	set completefunc=CompleteMonths
<

INSERT COMPLETION POPUP MENU				*ins-completion-menu*
							*popupmenu-completion*
Vim can display the matches in a simplistic popup menu.

The menu is used when:
- The 'completeopt' option contains "menu" or "menuone".
- The terminal supports at least 8 colors.
- There are at least two matches.  One if "menuone" is used.

The 'pumheight' option can be used to set a maximum height.  The default is to
use all space available.
The 'pumwidth' option can be used to set a minimum width.  The default is 15
characters.

There are three states:
1. A complete match has been inserted, e.g., after using CTRL-N or CTRL-P.
2. A cursor key has been used to select another match.  The match was not
   inserted then, only the entry in the popup menu is highlighted.
3. Only part of a match has been inserted and characters were typed or the
   backspace key was used.  The list of matches was then adjusted for what is
   in front of the cursor.

You normally start in the first state, with the first match being inserted.
When "longest" is in 'completeopt' and there is more than one match you start
in the third state.

If you select another match, e.g., with CTRL-N or CTRL-P, you go to the first
state.  This doesn't change the list of matches.

When you are back at the original text then you are in the third state.  To
get there right away you can use a mapping that uses CTRL-P right after
starting the completion: >
	:imap <F7> <C-N><C-P>
<
						*popupmenu-keys*
In the first state these keys have a special meaning:
<BS> and CTRL-H   Delete one character, find the matches for the word before
		  the cursor.  This reduces the list of matches, often to one
		  entry, and switches to the second state.
Any non-special character:
		  Stop completion without changing the match and insert the
		  typed character.

In the second and third state these keys have a special meaning:
<BS> and CTRL-H   Delete one character, find the matches for the shorter word
		  before the cursor.  This may find more matches.
CTRL-L		  Add one character from the current match, may reduce the
		  number of matches.
any printable, non-white character:
		  Add this character and reduce the number of matches.

In all three states these can be used:
CTRL-Y		  Yes: Accept the currently selected match and stop completion.
CTRL-E		  End completion, go back to what was there before selecting a
		  match (what was typed or longest common string).
<PageUp>	  Select a match several entries back, but don't insert it.
<PageDown>	  Select a match several entries further, but don't insert it.
<Up>		  Select the previous match, as if CTRL-P was used, but don't
		  insert it.
<Down>		  Select the next match, as if CTRL-N was used, but don't
		  insert it.
<Space> or <Tab>  Stop completion without changing the match and insert the
		  typed character.

The behavior of the <Enter> key depends on the state you are in:
first state:	  Use the text as it is and insert a line break.
second state:	  Insert the currently selected match.
third state:	  Use the text as it is and insert a line break.

In other words: If you used the cursor keys to select another entry in the
list of matches then the <Enter> key inserts that match.  If you typed
something else then <Enter> inserts a line break.


The colors of the menu can be changed with these highlight groups:
Pmenu		normal item  |hl-Pmenu|
PmenuSel	selected item  |hl-PmenuSel|
PmenuSbar	scrollbar  |hl-PmenuSbar|
PmenuThumb	thumb of the scrollbar  |hl-PmenuThumb|

There are no special mappings for when the popup menu is visible.  However,
you can use an Insert mode mapping that checks the |pumvisible()| function to
do something different.  Example: >
	:inoremap <Down> <C-R>=pumvisible() ? "\<lt>C-N>" : "\<lt>Down>"<CR>

You can use of <expr> in mapping to have the popup menu used when typing a
character and some condition is met.  For example, for typing a dot: >
	inoremap <expr> . MayComplete()
	func MayComplete()
	    if (can complete)
	      return ".\<C-X>\<C-O>"
	    endif
	    return '.'
	endfunc

See |:map-<expr>| for more info.


FILETYPE-SPECIFIC REMARKS FOR OMNI COMPLETION	    *compl-omni-filetypes*

The file used for {filetype} should be autoload/{filetype}complete.vim
in 'runtimepath'.  Thus for "java" it is autoload/javacomplete.vim.


C							*ft-c-omni*

Completion of C code requires a tags file.  You should use Universal/
Exuberant ctags, because it adds extra information that is needed for
completion.  You can find it here:
	Universal Ctags: https://ctags.io
	Exuberant Ctags: http://ctags.sourceforge.net

Universal Ctags is preferred, Exuberant Ctags is no longer being developed.

For Exuberant ctags, version 5.6 or later is recommended.  For version 5.5.4
you should add a patch that adds the "typename:" field:
	ftp://ftp.vim.org/pub/vim/unstable/patches/ctags-5.5.4.patch
A compiled .exe for MS-Windows can be found at:
	http://ctags.sourceforge.net/
	https://github.com/universal-ctags/ctags-win32

If you want to complete system functions you can do something like this.  Use
ctags to generate a tags file for all the system header files: >
	% ctags -R -f ~/.vim/systags /usr/include /usr/local/include
In your vimrc file add this tags file to the 'tags' option: >
	set tags+=~/.vim/systags

When using CTRL-X CTRL-O after a name without any "." or "->" it is completed
from the tags file directly.  This works for any identifier, also function
names.  If you want to complete a local variable name, which does not appear
in the tags file, use CTRL-P instead.

When using CTRL-X CTRL-O after something that has "." or "->" Vim will attempt
to recognize the type of the variable and figure out what members it has.
This means only members valid for the variable will be listed.

When a member name already was complete, CTRL-X CTRL-O will add a "." or
"->" for composite types.

Vim doesn't include a C compiler, only the most obviously formatted
declarations are recognized.  Preprocessor stuff may cause confusion.
When the same structure name appears in multiple places all possible members
are included.


CSS							*ft-css-omni*

Complete properties and their appropriate values according to CSS 2.1
specification.


HTML							*ft-html-omni*
XHTML							*ft-xhtml-omni*

CTRL-X CTRL-O provides completion of various elements of (X)HTML files.  It is
designed to support writing of XHTML 1.0 Strict files but will also work for
other versions of HTML. Features:

- after "<" complete tag name depending on context (no div suggestion inside
  of an a tag); '/>' indicates empty tags
- inside of tag complete proper attributes (no width attribute for an a tag);
  show also type of attribute; '*' indicates required attributes
- when attribute has limited number of possible values help to complete them
- complete names of entities
- complete values of "class" and "id" attributes with data obtained from
  <style> tag and included CSS files
- when completing value of "style" attribute or working inside of "style" tag
  switch to |ft-css-omni| completion
- when completing values of events attributes or working inside of "script"
  tag switch to |ft-javascript-omni| completion
- when used after "</" CTRL-X CTRL-O will close the last opened tag

Note: When used first time completion menu will be shown with little delay
- this is time needed for loading of data file.
Note: Completion may fail in badly formatted documents. In such case try to
run |:make| command to detect formatting problems.


HTML flavor						*html-flavor*

The default HTML completion depends on the filetype.  For HTML files it is
HTML 4.01 Transitional ('filetype' is "html"), for XHTML it is XHTML 1.0
Strict ('filetype' is "xhtml").

When doing completion outside of any other tag you will have possibility to
choose DOCTYPE and the appropriate data file will be loaded and used for all
next completions.

More about format of data file in |xml-omni-datafile|. Some of the data files
may be found on the Vim website (|www|).

Note that b:html_omni_flavor may point to a file with any XML data.  This
makes possible to mix PHP (|ft-php-omni|) completion with any XML dialect
(assuming you have data file for it).  Without setting that variable XHTML 1.0
Strict will be used.


JAVASCRIPT					       *ft-javascript-omni*

Completion of most elements of JavaScript language and DOM elements.

Complete:

- variables
- function name; show function arguments
- function arguments
- properties of variables trying to detect type of variable
- complete DOM objects and properties depending on context
- keywords of language

Completion works in separate JavaScript files (&ft==javascript), inside of
<script> tag of (X)HTML and in values of event attributes (including scanning
of external files).

DOM compatibility

At the moment (beginning of 2006) there are two main browsers - MS Internet
Explorer and Mozilla Firefox. These two applications are covering over 90% of
market. Theoretically standards are created by W3C organisation
(http://www.w3c.org) but they are not always followed/implemented.

		IE	FF	W3C  Omni completion ~
		+/-	+/-	+    +		     ~
		+	+	-    +		     ~
		+	-	-    -		     ~
		-	+	-    -		     ~

Regardless from state of implementation in browsers but if element is defined
in standards, completion plugin will place element in suggestion list. When
both major engines implemented element, even if this is not in standards it
will be suggested. All other elements are not placed in suggestion list.


PHP							*ft-php-omni*

Completion of PHP code requires a tags file for completion of data from
external files and for class aware completion. You should use Universal/
Exuberant ctags version 5.5.4 or newer. You can find it here:

	Universal Ctags: https://ctags.io
	Exuberant Ctags: http://ctags.sourceforge.net

Script completes:

- after $ variables name
  - if variable was declared as object add "->", if tags file is available show
    name of class
  - after "->" complete only function and variable names specific for given
    class. To find class location and contents tags file is required. Because
    PHP isn't strongly typed language user can use @var tag to declare class: >

	/* @var $myVar myClass */
	$myVar->
<
    Still, to find myClass contents tags file is required.

- function names with additional info:
  - in case of built-in functions list of possible arguments and after | type
    data returned by function
  - in case of user function arguments and name of file where function was
    defined (if it is not current file)

- constants names
- class names after "new" declaration


Note: when doing completion first time Vim will load all necessary data into
memory. It may take several seconds. After next use of completion delay
should not be noticeable.

Script detects if cursor is inside <?php ?> tags. If it is outside it will
automatically switch to HTML/CSS/JavaScript completion. Note: contrary to
original HTML files completion of tags (and only tags) isn't context aware.


RUBY							*ft-ruby-omni*

Completion of Ruby code requires that vim be built with |+ruby|.

Ruby completion will parse your buffer on demand in order to provide a list of
completions.  These completions will be drawn from modules loaded by 'require'
and modules defined in the current buffer.

The completions provided by CTRL-X CTRL-O are sensitive to the context:

	  CONTEXT			   COMPLETIONS PROVIDED ~

 1. Not inside a class definition    Classes, constants and globals

 2. Inside a class definition	     Methods or constants defined in the class

 3. After '.', '::' or ':'	     Methods applicable to the object being
				       dereferenced

 4. After ':' or ':foo'		     Symbol name (beginning with 'foo')

Notes:
 - Vim will load/evaluate code in order to provide completions.  This may
   cause some code execution, which may be a concern. This is no longer
   enabled by default, to enable this feature add >
     let g:rubycomplete_buffer_loading = 1
<- In context 1 above, Vim can parse the entire buffer to add a list of
   classes to the completion results. This feature is turned off by default,
   to enable it add >
     let g:rubycomplete_classes_in_global = 1
<  to your vimrc
 - In context 2 above, anonymous classes are not supported.
 - In context 3 above, Vim will attempt to determine the methods supported by
   the object.
 - Vim can detect and load the Rails environment for files within a rails
   project. The feature is disabled by default, to enable it add >
     let g:rubycomplete_rails = 1
<  to your vimrc


SYNTAX							*ft-syntax-omni*

Vim has the ability to color syntax highlight nearly 500 languages.  Part of
this highlighting includes knowing what keywords are part of a language.  Many
filetypes already have custom completion scripts written for them, the
syntaxcomplete plugin provides basic completion for all other filetypes.  It
does this by populating the omni completion list with the text Vim already
knows how to color highlight.  It can be used for any filetype and provides a
minimal language-sensitive completion.

To enable syntax code completion you can run: >
    setlocal omnifunc=syntaxcomplete#Complete

You can automate this by placing the following in your |.vimrc| (after any
":filetype" command): >
    if has("autocmd") && exists("+omnifunc")
	autocmd Filetype *
		    \	if &omnifunc == "" |
		    \		setlocal omnifunc=syntaxcomplete#Complete |
		    \	endif
    endif

The above will set completion to this script only if a specific plugin does
not already exist for that filetype.

Each filetype can have a wide range of syntax items.  The plugin allows you to
customize which syntax groups to include or exclude from the list.  Let's have
a look at the PHP filetype to see how this works.

If you edit a file called, index.php, run the following command: >
    syntax list

The first thing you will notice is that there are many different syntax groups.
The PHP language can include elements from different languages like HTML,
JavaScript and many more.  The syntax plugin will only include syntax groups
that begin with the filetype, "php", in this case.  For example these syntax
groups are included by default with the PHP: phpEnvVar, phpIntVar,
phpFunctions.

If you wish non-filetype syntax items to also be included, you can use a
regular expression syntax (added in version 13.0 of
autoload/syntaxcomplete.vim) to add items.  Looking at the output from
":syntax list" while editing a PHP file I can see some of these entries: >
    htmlArg,htmlTag,htmlTagName,javaScriptStatement,javaScriptGlobalObjects

To pick up any JavaScript and HTML keyword syntax groups while editing a PHP
file, you can use 3 different regexs, one for each language.  Or you can
simply restrict the include groups to a particular value, without using
a regex string: >
    let g:omni_syntax_group_include_php = 'php\w\+,javaScript\w\+,html\w\+'
    let g:omni_syntax_group_include_php = 'phpFunctions,phpMethods'
<
The basic form of this variable is: >
    let g:omni_syntax_group_include_{filetype} = 'regex,comma,separated'

The PHP language has an enormous number of items which it knows how to syntax
highlight.  These items will be available within the omni completion list.

Some people may find this list unwieldy or are only interested in certain
items.  There are two ways to prune this list (if necessary).  If you find
certain syntax groups you do not wish displayed you can use two different
methods to identify these groups.  The first specifically lists the syntax
groups by name.  The second uses a regular expression to identify both
syntax groups.  Simply add one the following to your vimrc: >
    let g:omni_syntax_group_exclude_php = 'phpCoreConstant,phpConstant'
    let g:omni_syntax_group_exclude_php = 'php\w*Constant'

Add as many syntax groups to this list by comma separating them.  The basic
form of this variable is: >
    let g:omni_syntax_group_exclude_{filetype} = 'regex,comma,separated'

You can create as many of these variables as you need, varying only the
filetype at the end of the variable name.

The plugin uses the isKeyword option to determine where word boundaries are
for the syntax items.  For example, in the Scheme language completion should
include the "-", call-with-output-file.  Depending on your filetype, this may
not provide the words you are expecting.  Setting the
g:omni_syntax_use_iskeyword option to 0 will force the syntax plugin to break
on word characters.   This can be controlled adding the following to your
vimrc: >
    let g:omni_syntax_use_iskeyword = 0

For plugin developers, the plugin exposes a public function OmniSyntaxList.
This function can be used to request a List of syntax items.  When editing a
SQL file (:e syntax.sql) you can use the ":syntax list" command to see the
various groups and syntax items.  For example: >
    syntax list

Yields data similar to this:
    sqlOperator    xxx some prior all like and any escape exists in is not ~
                       or intersect minus between distinct ~
                       links to Operator ~
    sqlType        xxx varbit varchar nvarchar bigint int uniqueidentifier ~
                       date money long tinyint unsigned xml text smalldate ~
                       double datetime nchar smallint numeric time bit char ~
                       varbinary binary smallmoney ~
                       image float integer timestamp real decimal ~

There are two syntax groups listed here: sqlOperator and sqlType.  To retrieve
a List of syntax items you can call OmniSyntaxList a number of different
ways.  To retrieve all syntax items regardless of syntax group:  >
    echo OmniSyntaxList( [] )

To retrieve only the syntax items for the sqlOperator syntax group: >
    echo OmniSyntaxList( ['sqlOperator'] )

To retrieve all syntax items for both the sqlOperator and sqlType groups: >
    echo OmniSyntaxList( ['sqlOperator', 'sqlType'] )

A regular expression can also be used: >
    echo OmniSyntaxList( ['sql\w\+'] )

From within a plugin, you would typically assign the output to a List: >
    let myKeywords = []
    let myKeywords = OmniSyntaxList( ['sqlKeyword'] )


SQL							*ft-sql-omni*

Completion for the SQL language includes statements, functions, keywords.
It will also dynamically complete tables, procedures, views and column lists
with data pulled directly from within a database.  For detailed instructions
and a tutorial see |omni-sql-completion|.

The SQL completion plugin can be used in conjunction with other completion
plugins.  For example, the PHP filetype has its own completion plugin.
Since PHP is often used to generate dynamic website by accessing a database,
the SQL completion plugin can also be enabled.  This allows you to complete
PHP code and SQL code at the same time.


XML							*ft-xml-omni*

Vim 7 provides a mechanism for context aware completion of XML files.  It
depends on a special |xml-omni-datafile| and two commands: |:XMLns| and
|:XMLent|.  Features are:

- after "<" complete the tag name, depending on context
- inside of a tag complete proper attributes
- when an attribute has a limited number of possible values help to complete
  them
- complete names of entities (defined in |xml-omni-datafile| and in the
  current file with "<!ENTITY" declarations)
- when used after "</" CTRL-X CTRL-O will close the last opened tag

Format of XML data file					*xml-omni-datafile*

XML data files are stored in the "autoload/xml" directory in 'runtimepath'.
Vim distribution provides examples of data files in the
"$VIMRUNTIME/autoload/xml" directory.  They have a meaningful name which will
be used in commands.  It should be a unique name which will not create
conflicts.  For example, the name xhtml10s.vim means it is the data file for
XHTML 1.0 Strict.

Each file contains a variable with a name like g:xmldata_xhtml10s . It is
a compound from two parts:

1. "g:xmldata_"  general prefix, constant for all data files
2. "xhtml10s"    the name of the file and the name of the described XML
		 dialect; it will be used as an argument for the |:XMLns|
		 command

Part two must be exactly the same as name of file.

The variable is a |Dictionary|.  Keys are tag names and each value is a two
element |List|.  The first element of the List is also a List with the names
of possible children.  The second element is a |Dictionary| with the names of
attributes as keys and the possible values of attributes as values.  Example: >

    let g:xmldata_crippled = {
    \ "vimxmlentities": ["amp", "lt", "gt", "apos", "quot"],
    \ 'vimxmlroot': ['tag1'],
    \ 'tag1':
    \ [ ['childoftag1a', 'childoftag1b'], {'attroftag1a': [],
    \ 'attroftag1b': ['valueofattr1', 'valueofattr2']}],
    \ 'childoftag1a':
    \ [ [], {'attrofchild': ['attrofchild']}],
    \ 'childoftag1b':
    \ [ ['childoftag1a'], {'attrofchild': []}],
    \ "vimxmltaginfo": {
    \ 'tag1': ['Menu info', 'Long information visible in preview window']},
    \ 'vimxmlattrinfo': {
    \ 'attrofchild': ['Menu info', 'Long information visible in preview window']}}

This example would be put in the "autoload/xml/crippled.vim" file and could
help to write this file: >

    <tag1 attroftag1b="valueofattr1">
        <childoftag1a attrofchild>
                &amp; &lt;
        </childoftag1a>
        <childoftag1b attrofchild="5">
            <childoftag1a>
                &gt; &apos; &quot;
            </childoftag1a>
        </childoftag1b>
    </tag1>

In the example four special elements are visible:

1. "vimxmlentities" - a special key with List containing entities of this XML
   dialect.
2. If the list containing possible values of attributes has one element and
   this element is equal to the name of the attribute this attribute will be
   treated as boolean and inserted as 'attrname' and not as 'attrname="'
3. "vimxmltaginfo" - a special key with a Dictionary containing tag
   names as keys and two element List as values, for additional menu info and
   the long description.
4. "vimxmlattrinfo" - special key with Dictionary containing attribute names
   as keys and two element List as values, for additional menu info and long
   description.

Note: Tag names in the data file MUST not contain a namespace description.
Check xsl.vim for an example.
Note: All data and functions are publicly available as global
variables/functions and can be used for personal editing functions.


DTD -> Vim							*dtd2vim*

On |www| is the script |dtd2vim| which parses DTD and creates an XML data file
for Vim XML omni completion.

    dtd2vim: http://www.vim.org/scripts/script.php?script_id=1462

Check the beginning of that file for usage details.
The script requires perl and:

    perlSGML: http://savannah.nongnu.org/projects/perlsgml


Commands

:XMLns {name} [{namespace}]					*:XMLns*

Vim has to know which data file should be used and with which namespace.  For
loading of the data file and connecting data with the proper namespace use
|:XMLns| command.  The first (obligatory) argument is the name of the data
(xhtml10s, xsl).  The second argument is the code of namespace (h, xsl).  When
used without a second argument the dialect will be used as default - without
namespace declaration.  For example to use XML completion in .xsl files: >

	:XMLns xhtml10s
	:XMLns xsl xsl


:XMLent {name}							*:XMLent*

By default entities will be completed from the data file of the default
namespace.  The XMLent command should be used in case when there is no default
namespace: >

	:XMLent xhtml10s

Usage

While used in this situation (after declarations from previous part, | is
cursor position): >

	<|

Will complete to an appropriate XHTML tag, and in this situation: >

	<xsl:|

Will complete to an appropriate XSL tag.


The script xmlcomplete.vim, provided through the |autoload| mechanism,
has the xmlcomplete#GetLastOpenTag() function which can be used in XML files
to get the name of the last open tag (b:unaryTagsStack has to be defined): >

	:echo xmlcomplete#GetLastOpenTag("b:unaryTagsStack")



==============================================================================
8. Insert mode commands					*inserting*

The following commands can be used to insert new text into the buffer.  They
can all be undone and repeated with the "." command.

							*a*
a			Append text after the cursor [count] times.  If the
			cursor is in the first column of an empty line Insert
			starts there.  But not when 'virtualedit' is set!

							*A*
A			Append text at the end of the line [count] times.
			For using "A" in Visual block mode see |v_b_A|.

<insert>	or				*i* *insert* *<Insert>*
i			Insert text before the cursor [count] times.
			When using CTRL-O in Insert mode |i_CTRL-O| the count
			is not supported.

							*I*
I			Insert text before the first non-blank in the line
			[count] times.
			When the 'H' flag is present in 'cpoptions' and the
			line only contains blanks, insert start just before
			the last blank.
			For using "I" in Visual block mode see |v_b_I|.

							*gI*
gI			Insert text in column 1 [count] times.

							*gi*
gi			Insert text in the same position as where Insert mode
			was stopped last time in the current buffer.
			This uses the |'^| mark.  It's different from "`^i"
			when the mark is past the end of the line.
			The position is corrected for inserted/deleted lines,
			but NOT for inserted/deleted characters.
			When the |:keepjumps| command modifier is used the |'^|
			mark won't be changed.

							*o*
o			Begin a new line below the cursor and insert text,
			repeat [count] times.
			When the '#' flag is in 'cpoptions' the count is
			ignored.

							*O*
O			Begin a new line above the cursor and insert text,
			repeat [count] times.
			When the '#' flag is in 'cpoptions' the count is
			ignored.

These commands are used to start inserting text.  You can end insert mode with
<Esc>.  See |mode-ins-repl| for the other special characters in Insert mode.
The effect of [count] takes place after Insert mode is exited.

When 'autoindent' is on, the indent for a new line is obtained from the
previous line.  When 'smartindent' or 'cindent' is on, the indent for a line
is automatically adjusted for C programs.

'formatoptions' can be set to copy the comment leader when opening a new
line.

'textwidth' can be set to the maximum width for a line.  When a line becomes
too long when appending characters a line break is automatically inserted.


==============================================================================
9. Ex insert commands					*inserting-ex*

							*:a* *:append*
:{range}a[ppend][!]	Insert several lines of text below the specified
			line.  If the {range} is missing, the text will be
			inserted after the current line.
			Adding [!] toggles 'autoindent' for the time this
			command is executed.
			This command is not supported in |Vim9| script,
			because it is too easily confused with a variable
			name.

							*:i* *:in* *:insert*
:{range}i[nsert][!]	Insert several lines of text above the specified
			line.  If the {range} is missing, the text will be
			inserted before the current line.
			Adding [!] toggles 'autoindent' for the time this
			command is executed.
			This command is not supported in |Vim9| script,
			because it is too easily confused with a variable
			name.

These two commands will keep on asking for lines, until you type a line
containing only a ".".  Watch out for lines starting with a backslash, see
|line-continuation|.

Text typed after a "|" command separator is used first. So the following
command in ex mode: >
	:a|one
	two
	.
	:visual
appends the following text, after the cursor line: >
	one
	two
<
In |Ex-mode|, when these commands are used with |:global| or |:vglobal| then
the lines are obtained from the text following the command.  Separate lines
with a NL escaped with a backslash: >
	:global/abc/insert\
	one line\
	another line
The final "." is not needed then.

NOTE: ":append" and ":insert" don't work properly in between ":if" and
":endif", ":for" and ":endfor", ":while" and ":endwhile".

							*:start* *:startinsert*
:star[tinsert][!]	Start Insert mode just after executing this command.
			Works like typing "i" in Normal mode.  When the ! is
			included it works like "A", append to the line.
			Otherwise insertion starts at the cursor position.
			Note that when using this command in a function or
			script, the insertion only starts after the function
			or script is finished.
			This command does not work from |:normal|.

							*:stopi* *:stopinsert*
:stopi[nsert]		Stop Insert mode as soon as possible.  Works like
			typing <Esc> in Insert mode.
			Can be used in an autocommand, example: >
				:au BufEnter scratch stopinsert
<
					*replacing-ex* *:startreplace*
:startr[eplace][!]	Start Replace mode just after executing this command.
			Works just like typing "R" in Normal mode.  When the
			! is included it acts just like "$R" had been typed
			(ie. begin replace mode at the end-of-line).  Other-
			wise replacement begins at the cursor position.
			Note that when using this command in a function or
			script that the replacement will only start after
			the function or script is finished.

							*:startgreplace*
:startg[replace][!]	Just like |:startreplace|, but use Virtual Replace
			mode, like with |gR|.

==============================================================================
10. Inserting a file					*inserting-file*

							*:r* *:re* *:read*
:r[ead] [++opt] [name]
			Insert the file [name] (default: current file) below
			the cursor.
			See |++opt| for the possible values of [++opt].

:{range}r[ead] [++opt] [name]
			Insert the file [name] (default: current file) below
			the specified line.
			See |++opt| for the possible values of [++opt].

							*:r!* *:read!*
:[range]r[ead] [++opt] !{cmd}
			Execute {cmd} and insert its standard output below
			the cursor or the specified line.  A temporary file is
			used to store the output of the command which is then
			read into the buffer.  'shellredir' is used to save
			the output of the command, which can be set to include
			stderr or not.  {cmd} is executed like with ":!{cmd}",
			any '!' is replaced with the previous command |:!|.
			See |++opt| for the possible values of [++opt].

These commands insert the contents of a file, or the output of a command,
into the buffer.  They can be undone.  They cannot be repeated with the "."
command.  They work on a line basis, insertion starts below the line in which
the cursor is, or below the specified line.  To insert text above the first
line use the command ":0r {name}".

After the ":read" command, the cursor is left on the first non-blank in the
first new line.  If in Ex mode, then the cursor is left on the last new
line (sorry, this is Vi compatible).

If a file name is given with ":r", it becomes the alternate file.  This can be
used, for example, when you want to edit that file instead: ":e! #".  This can
be switched off by removing the 'a' flag from the 'cpoptions' option.

Of the [++opt] arguments one is specifically for ":read", the ++edit argument.
This is useful when the ":read" command is actually used to read a file into
the buffer as if editing that file.  Use this command in an empty buffer: >
	:read ++edit filename
The effect is that the 'fileformat', 'fileencoding', 'bomb', etc. options are
set to what has been detected for "filename".  Note that a single empty line
remains, you may want to delete it.

							*file-read*
The 'fileformat' option sets the <EOL> style for a file:
'fileformat'    characters	   name				~
  "dos"		<CR><NL> or <NL>   DOS format
  "unix"	<NL>		   Unix format
  "mac"		<CR>		   Mac format
Previously 'textmode' was used.  It is obsolete now.

If 'fileformat' is "dos", a <CR> in front of an <NL> is ignored and a CTRL-Z
at the end of the file is ignored.

If 'fileformat' is "mac", a <NL> in the file is internally represented by a
<CR>.  This is to avoid confusion with a <NL> which is used to represent a
<NUL>.  See |CR-used-for-NL|.

If the 'fileformats' option is not empty Vim tries to recognize the type of
<EOL> (see |file-formats|).  However, the 'fileformat' option will not be
changed, the detected format is only used while reading the file.
A similar thing happens with 'fileencodings'.

On non-Win32 systems the message "[dos format]" is shown if a file is read in
DOS format, to remind you that something unusual is done.
On Macintosh and Win32 the message "[unix format]" is shown if a file is read
in Unix format.
On non-Macintosh systems, the message "[mac format]" is shown if a file is
read in Mac format.

An example on how to use ":r !": >
	:r !uuencode binfile binfile
This command reads "binfile", uuencodes it and reads it into the current
buffer.  Useful when you are editing e-mail and want to include a binary
file.

							*read-messages*
When reading a file Vim will display a message with information about the read
file.  In the table is an explanation for some of the items.  The others are
self explanatory.  Using the long or the short version depends on the
'shortmess' option.

	long		short		meaning ~
	[readonly]	{RO}		the file is write protected
	[fifo/socket]			using a stream
	[fifo]				using a fifo stream
	[socket]			using a socket stream
	[CR missing]			reading with "dos" 'fileformat' and a
					NL without a preceding CR was found.
	[NL found]			reading with "mac" 'fileformat' and a
					NL was found (could be "unix" format)
	[long lines split]		at least one line was split in two
	[NOT converted]			conversion from 'fileencoding' to
					'encoding' was desired but not
					possible
	[converted]			conversion from 'fileencoding' to
					'encoding' done
	[crypted]			file was decrypted
	[READ ERRORS]			not all of the file could be read


 vim:tw=78:ts=8:noet:ft=help:norl:
