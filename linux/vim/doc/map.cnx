*map.txt*       适用于 Vim version 9.1.  最后修订: 2024 Oct 08


		  VIM REFERENCE MANUAL    by Bram Moolenaar


键位映射，缩写及用户定义命令

当前主题分别在用户手册的|05.4|, |24.7| 及 |40.1|章节介绍

1. 键位映射			|key-mapping|
   1.1 映射命令					|:map-commands|
   1.2 特殊参数					|:map-arguments|
   1.3 映射及模式				|:map-modes|
   1.4 列出映射					|map-listing|
   1.5 映射特殊键				|:map-special-keys|
   1.6 特殊字符					|:map-special-chars|
   1.7 映射键位建议				|map-which-keys|
   1.8 样例					|map-examples|
   1.9 使用映射					|map-typing|
   1.10 映射alt按键				|:map-alt-keys|
   1.11 Mapping meta-keys			|:map-meta-keys|
   1.12 Mapping super-keys or command keys	|:map-super-keys|
   1.13 Mapping in modifyOtherKeys mode		|modifyOtherKeys|
   1.14 Mapping with Kitty keyboard protocol	|kitty-keyboard-protocol|
   1.15 映射操作符				|:map-operator|
2. 缩写				|abbreviations|
3. 局部映射和函数		|script-local|
4. 用户定义命令			|user-commands|

==============================================================================
1. 键位映射				*key-mapping* *mapping* *macro*

键位映射被用来改变按下按键的意义. 最普遍的用法是使用功能键定义命令序列. 例如:
>
	:map <F2> a<C-R>=strftime("%c")<CR><Esc>

这条命令会把当前的日期和时间添加到光标之后 (注意<>符号 |<>|).


1.1 映射命令						*:map-commands*

有许多命令用来创建新映射、移除映射及列出映射. 查阅|map-overview|了解各种 "映射"
的格式及它们与编辑模式的关系. 

{lhs}	means left-hand-side (左值) 	*{lhs}*
{rhs}	means right-hand-side (右值) 	*{rhs}*

:map	{lhs} {rhs}		|mapmode-nvo|		*:map*
:nm[ap]	{lhs} {rhs}		|mapmode-n|		*:nm* *:nmap*
:vm[ap]	{lhs} {rhs}		|mapmode-v|		*:vm* *:vmap*
:xm[ap]	{lhs} {rhs}		|mapmode-x|		*:xm* *:xmap*
:smap	{lhs} {rhs}		|mapmode-s|		    *:smap*
:om[ap]	{lhs} {rhs}		|mapmode-o|		*:om* *:omap*
:map!	{lhs} {rhs}		|mapmode-ic|		*:map!*
:im[ap]	{lhs} {rhs}		|mapmode-i|		*:im* *:imap*
:lm[ap]	{lhs} {rhs}		|mapmode-l|		*:lm* *:lma* *:lmap*
:cm[ap]	{lhs} {rhs}		|mapmode-c|		*:cm* *:cmap*
:tma[p]	{lhs} {rhs}		|mapmode-t|		*:tma* *:tmap*
			在应用映射命令的模式中将左值按键序列映射为右值按键序列,
			映射的结果 (包含右值按键序列) 会继续映射新的按键,
			这允许嵌套和递归使用映射. 
			注意: 尾随空格也会被包含在右值映射序列中,因为空格是有效
			      的普通模式命令. 查阅|map-trailing-white|. 
			      >
				译者注: 映射命令后面无法注释也是这个原因

						*:nore* *:norem*
:no[remap]  {lhs} {rhs}		|mapmode-nvo|	*:no*  *:noremap* *:nor*
:nn[oremap] {lhs} {rhs}		|mapmode-n|	*:nn*  *:nnoremap*
:vn[oremap] {lhs} {rhs}		|mapmode-v|	*:vn*  *:vnoremap*
:xn[oremap] {lhs} {rhs}		|mapmode-x|	*:xn*  *:xnoremap*
:snor[emap] {lhs} {rhs}		|mapmode-s|	*:snor* *:snore* *:snoremap*
:ono[remap] {lhs} {rhs}		|mapmode-o|	*:ono* *:onoremap*
:no[remap]! {lhs} {rhs}		|mapmode-ic|	*:no!* *:noremap!*
:ino[remap] {lhs} {rhs}		|mapmode-i|	*:ino* *:inor* *:inoremap*
:ln[oremap] {lhs} {rhs}		|mapmode-l|	*:ln*  *:lnoremap*
:cno[remap] {lhs} {rhs}		|mapmode-c|	*:cno* *:cnor* *:cnoremap*
:tno[remap] {lhs} {rhs}		|mapmode-t|	*:tno* *:tnoremap*
			在应用映射命令的模式中将左值按键序列映射为右值按键序列.
			不允许继续映射右值序列以避免嵌套和递归映射.
			通常用于重定义命令. 
			注意: 除了|i_CTRL-]|及|c_CTRL-]|之外右值序列中的
			      按键也不会触发缩写. >
			      译者注: |i_CTRL-]|及|c_CTRL-]|分别是插入模式及
				      命令行模式触发缩写的命令, 该命令出现在
				      右值序列应以字面形式出现而非字符形式出现
<
			注意: 当<Plug>出现在右值序列中时, 右值序列总是会被引用,
			      即便不允许重映射. >
			      译者注: <Plug>是特殊键, 通常用于映射脚本函数, 
				      类似的还有<Sid>键


:unm[ap]  {lhs}			|mapmode-nvo|		*:unm*  *:unmap*
:nun[map] {lhs}			|mapmode-n|		*:nun*  *:nunmap*
:vu[nmap] {lhs}			|mapmode-v|		*:vu*   *:vunmap*
:xu[nmap] {lhs}			|mapmode-x|		*:xu*   *:xunmap*
:sunm[ap] {lhs}			|mapmode-s|		*:sunm* *:sunmap*
:ou[nmap] {lhs}			|mapmode-o|		*:ou*   *:ounmap*
:unm[ap]! {lhs}			|mapmode-ic|		*:unm!* *:unmap!*
:iu[nmap] {lhs}			|mapmode-i|		*:iu*   *:iunmap*
:lu[nmap] {lhs}			|mapmode-l|		*:lu*   *:lunmap*
:cu[nmap] {lhs}			|mapmode-c|		*:cu*   *:cun* *:cunmap*
:tunma[p] {lhs}			|mapmode-t|		*:tunma* *:tunmap*
			移除映射命令命令应用模式的左值按键序列映射. 映射仍然会
			在其他模式保留映射. 
			当左值按键序列匹配另一个映射的右值按键序列时也会阻止其
			进一步映射. 这将用于当缩写被应用的时候. 
			注意: 尾随空格会被包含在左值按键序列中. 
			      查阅|map-trailing-white|

:mapc[lear]			|mapmode-nvo|		*:mapc*   *:mapclear*
:nmapc[lear]			|mapmode-n|		*:nmapc*  *:nmapclear*
:vmapc[lear]			|mapmode-v|		*:vmapc*  *:vmapclear*
:xmapc[lear]			|mapmode-x|		*:xmapc*  *:xmapclear*
:smapc[lear]			|mapmode-s|		*:smapc*  *:smapclear*
:omapc[lear]			|mapmode-o|		*:omapc*  *:omapclear*
:mapc[lear]!			|mapmode-ic|		*:mapc!*  *:mapclear!*
:imapc[lear]			|mapmode-i|		*:imapc*  *:imapclear*
:lmapc[lear]			|mapmode-l|		*:lmapc*  *:lmapclear*
:cmapc[lear]			|mapmode-c|		*:cmapc*  *:cmapclear*
:tmapc[lear]			|mapmode-t|		*:tmapc*  *:tmapclear*
			移除映射命令应用的模式中所有的按键映射. 
			使用<buffer>参数移除buffer相关映射 |:map-<buffer>|
			警告: 这同时会移除|mac-standard-mappings|及
					  |dos-standard-mappings|

:map				|mapmode-nvo|
:nm[ap]				|mapmode-n|
:vm[ap]				|mapmode-v|
:xm[ap]				|mapmode-x|
:sm[ap]				|mapmode-s|
:om[ap]				|mapmode-o|
:map!				|mapmode-ic|
:im[ap]				|mapmode-i|
:lm[ap]				|mapmode-l|
:cm[ap]				|mapmode-c|
:tma[p]				|mapmode-t|
			列出所有映射命令应用模式的按键映射. 
			注意: ":map"及":map!"最常使用, 因为它们包含其他模式. 

:map    {lhs}			|mapmode-nvo|		*:map_l*
:nm[ap] {lhs}			|mapmode-n|		*:nmap_l*
:vm[ap] {lhs}			|mapmode-v|		*:vmap_l*
:xm[ap] {lhs}			|mapmode-x|		*:xmap_l*
:sm[ap] {lhs}			|mapmode-s|		*:smap_l*
:om[ap] {lhs}			|mapmode-o|		*:omap_l*
:map!   {lhs}			|mapmode-ic|		*:map_l!*
:im[ap] {lhs}			|mapmode-i|		*:imap_l*
:lm[ap] {lhs}			|mapmode-l|		*:lmap_l*
:cm[ap] {lhs}			|mapmode-c|		*:cmap_l*
:tma[p] {lhs}			|mapmode-t|		*:tmap_l*
			列出以左值序列按键开始的映射命令对应模式的按键映射. 

这些命令被用来映射按键或按键序列到字符串.可以使用这些命令将命令序列映射到功能键,
将一个按键转换为另一个按键, 等等操作. 查阅|:mkexrc|了解怎么保存和恢复当前的映射.

							*map-ambiguous*
当两组映射以相同的字符序列开始时, 它们是模棱两可的. 例如: >
	:imap aa foo
	:imap aaa bar
当Vim读取"aa"时, 它将需要再获取另一个字符以确定应该映射"aa"还是"aaa". 这意味着
键入"aa"之后映射并不会被展开, Vim会等待另一个字符的输入. 如果后续键入空格,
"foo"将会被插入并且键入的空格也会在随后被插入. 如果后续键入"a", 那么"bar"将会被
插入. >
  这里说的情况只会在快速输入文本时才会出现, vim背后有连续键入判断机制,
  如果键入"aa"后在阈值范围时间内不再继续键入内容则会被认为是键入了"aa"并在后续
  被映射为"for", 当然, 如果在阈值范围时间内键入的字符不匹配"aaa"则会立马将前面
  键入的"aa"映射为"foo"而无需等待.  |timeout| |timeoutlen| |ttimeout|

Trailing white space ~
							*map-trailing-white*
这个取消映射命令并不会生效: >
	:map @@ foo
	:unmap @@ | print

因为它会尝试取消"@@ "映射序列按键 (包含在命令分隔符前面的"|") . 另一个带有尾随
空格的例子: >
	unmap @@ 
	unmap @@     # Vim9 script comment
	unmap @@     " legacy script comment

这将会触发一个很难被鉴定的错误, 因为在取消映射命令`unmap @@`尾部的空白字符是
不可见的. 

通常的解决方法是将命令分隔符"|"放在被映射的按键的正后方. 在那之后才可以继续输入
空白字符或注释. >

	unmap @@|    # Vim9 script comment
	unmap @@|    " legacy script comment


1.2 特殊参数						*:map-arguments*

"<buffer>", "<nowait>", "<silent>", "<special>", "<script>", "<expr>" 及
"<unique>" 可以以任意顺序出现. 它们必须出现在命令其他参数之前的正后方. >
  这里的正后方依然需要采用" "分隔, 因为命令名必须以独立的<TOKEN>出现, 
  不然就是其他命令了. 
<

				    *:map-local* *:map-<buffer>* *:map-buffer*
				    *E224* *E225*
如果这些命令的第一个参数是"<buffer>", 映射将只会在当前buffer生效. 比如: >
	:map <buffer>  ,w  /[.,;]<CR>
之后还可以在其他buffer将",w"按键映射到其他的按键序列: >
	:map <buffer>  ,w  /[#&!]<CR>
buffer相关按键映射优先级高于全局按键映射.查阅下面<nowait>文档创建一个当存在一个
更长的全局按键映射时较短的不生效的buffer相关映射. 
"<buffer>"参数也可以用于清除映射: >
	:unmap <buffer> ,w
	:mapclear <buffer>
buffer相关映射的清除会在buffer被删除时进行而不是在buffer卸载时.就像局部选项一样.
相关文档|map-precedence|.

						*:map-<nowait>* *:map-nowait*
当定义buffer相关映射按键","时, 可能存在以","开头的全局映射. 之后需要键入另一个字
符用于让Vim知道是否该用","按键映射或使用更长的全局按键映射. 可视添加<nowait>参数
避免这种情况. 这样按键映射就会在匹配时立马生效, Vim不会等待后续的键入字符.
然而, 如果是已经被键入的字符则会被优先采用. 
注意: 这只会在<nowait>映射完全匹配且在其他特定匹配之前被触发时才会生效. 
      满足下列情况会生效: 
    - 只匹配buffer相关映射的情况, 因为这些映射总会在全局按键映射之前被触发. 
    - 存在另一个部分匹配的buffer相关映射, 但其被更早定义 (后定义会被先发现). >
      这里应该和Vim时间映射机制的栈队列相关
<
						*:map-<silent>* *:map-silent*
可以添加"<silent>"作为第一个参数以定义不会在命令行显示的按键映射. 例如: >
	:map <silent> ,h /Header<CR>
当使用这个按键映射时, 搜索字符串将不会被显示. 执行命令的消息依然会被发送. 可以
在被执行的命令前添加":silent"以关闭执行命令发送的消息. >
	:map <silent> ,h :exe ":silent normal /Header\r"<CR>
注意: 命令产生的效果也可能被静默, 比如, 当按键映射选择另一个命令行补全入口时将
不会被现实. 
弹窗提示依然有效, 比如, inputdialog().
将"<silent>"用于缩写也是可能的, 但会导致命令行重绘无法进行. 

						*:map-<special>* *:map-special*
使用<>标记为特殊按键定义映射, 即便"<"标志符可能出现在'cpoptions'中.
这在处理设置'cpoptions'出现的不被期望的副作用时非常有效. 例如: >
	:map <special> <F12> /Header<CR>
	译者注: 'cpoptions'的+=<会禁止Vim解析<>标记内的特殊键, 从而导致映射仅
		采用其字符字面量. 
<
						*:map-<script>* *:map-script*
如果这些命令的第一个参数是"<script>"并且被用于定义新的按键映射或缩写, 按键映射
将只会将右值序列中的字符重映射为以"<SID>"开头的、被定义为脚本相关的映射. 这可以
被用来避免脚本外的映射接口 (比如, 当CTRL-V在mswin.vim中被重映射时), 只使用被定义
在当前脚本中的其他映射. 
注意: ":map <script>"及":noremap <script>"有同样的效果. "<script>"影响命令作用.
更推荐使用":noremap <script>", 因为重映射被(大概率)禁止变得更清晰. 

				*:map-<unique>* *:map-unique* *E226* *E227*
如果这些命令的第一个参数是"<unique>"并且被用于定义新的映射或缩写, 如果映射或缩写
已经存在则会导致命令执行失败. 例如: >
	:map <unique> ,w  /[#&!]<CR>
当定义局部映射时会检查全局是否已经存在相同的映射. 下面是映射失败的例子: >
	:map ,w  /[#&!]<CR>
	:map <buffer> <unique> ,w  /[.,;]<CR>
如果想要映射键位并让它之后执行它之前所映射的按键, 看一看|maparg()| >
  这里是指应用maparg()函数获取之前映射的{rhs}, 然后再键位映射之后再进行恢复. 
<
						*:map-<expr>* *:map-expression*
如果这些命令的第一个参数是"<expr>"并且被用于定义新的映射或缩写, 剩余的参数则是
表达式. 表达式会被执行以获取被映射的{rhs}. 比如: >
	:inoremap <expr> . <SID>InsertDot()
s:InsertDoc()函数的结果将会被插入. 当满足某些条件时它能够检查光标之前的文本并
开始omni补全. 更推荐使用脚本局部函数以避免污染全局命名空间. 在右值序列使用<SID>
以便映射被定义的脚本能被找到. 

对于缩写|v:char|被设置用于触发缩写所键入的字符. 可以使用这个决定如何扩展{lhs}.
不应该插入或修改|v:char|.

如果想让映射不做任何事情, 可以让被执行的表达式返回空字符串. 如果某些改动需要Vim
完成整个主循环 (比如: 更新显示) , 返回"\<Ignore>". 这和返回"空"字符串类似, 
但会让Vim从获取输入的循环中返回. 比如: >
  译者注: 这里类似捕获的概念, 返回空字符串会导致Vim捕获输入. 返回"<Ignore>"则
	  不会处理这些输入而是交由其他接口进行处理. 而等待输入的接口则会保留之
	  前的输入. 
	func s:OpenPopup()
	  call popup_create(... arguments ...)
	  return "\<Ignore>"
	endfunc
	nnoremap <expr> <F3> <SID>OpenPopup()

记住表达式可能会在获取输入时在前一个命令被执行前执行. 比如: >
	func StoreColumn()
	  let g:column = col('.')
	  return 'x'
	endfunc
	nnoremap <expr> x StoreColumn()
	nmap ! f!x
注意g:colunm会在执行"f!"命令前获取值, 因为"x"是在"f!"被执行前执行的.
可以通过在表达式映射字符前插入<Ignore>解决: >
	nmap ! f!<Ignore>x

当在|Vim9|脚本中定义映射时, 表达式会在脚本的上下文中被执行. 这意味着脚本局部项
可以被表达式访问. 

小心表达式的副作用!  表达式会在获取字符输入时被执行, 这很可能导致命令失效. 
因为这个原因, 下面这些行为将会被阻止: 
- 修改缓冲区的文本 |textlock|
- 编辑另一个缓冲区
- |:normal|命令
- 可以在执行表达式期间移动光标, 但之后会被恢复
如果想要映射实现这些行为,可以让表达式返回的字符完成这些功能或使用|<Cmd>|映射代替 >
  即采用<Cmd>代替<Expr>

可以使用getchar()函数, 它会捕获后续输入的字符. 比如, 下面的映射: >
  inoremap <expr> <C-L> nr2char(getchar())
  inoremap <expr> <C-L>x "foo"
如果输入CTRL-L则不会触发映射, Vim需要再输入一个字符确定该使用的映射.如果键入"x"
第二个映射会被使用并插入"foo". 如果键入其他任意字符则第一个字符会被使用并且会
调用getchar()函数获取按下的键位并返回. 

下面是插入递增数字序列的例子: >
	let counter = 0
	inoremap <expr> <C-L> ListItem()
	inoremap <expr> <C-R> ListReset()

	func ListItem()
	  let g:counter += 1
	  return g:counter .. '. '
	endfunc

	func ListReset()
	  let g:counter = 0
	  return ''
	endfunc

CTRL-L插入下个数字, CTRL-R重置计数. CTRL-R返回一个空字符串以避免插入文本. 

注意: 在其他文本前面使用单个字节的0x80并不会生效, 它会被当作特殊键. >
  这里指的是映射中的特殊字符如"\<Up>"	     |special-key||terminal-key-codes|
  Vim内部存储的形式就是<80>ku |:echo "\<Up>\<Cmd>"|, 这种记录形式只对特殊标识符
  有效其余键位则通常为Ascii码. 注: 查阅了一些资料, 目前的理解是这样的.
  这个值应该是Vim内部使用的, 外部无法设置. 
<
						*<Cmd>* *:map-cmd*
特殊文本<Cmd>触发"命令映射", 这会在不修改编辑模式的情况下直接执行命令. 这可以使
用"<Cmd>...<CR>"的方式代替映射右值序列中的":...<CR>". 比如: >
	noremap x <Cmd>echo mode(1)<CR>
<
这种形式比在可视模式和操作符待定模式使用`:<C-U>`或在插入模式使用`<C-O>:`更灵活, 
因为这样映射的命令会直接在当前模式中执行而不是回到普通模式. 可视模式也适用这个
映射, 所以不需要适用|gv|命令即可执行命令. 命令可以直接在命令行模式中被调用. 
(否者将会需要提升时间效率, 这里应该是指不用<Cmd>需要额外的步骤执行命令, timer hacks)
在插入模式中使用<Cmd>的例子: >
	nnoremap <F3> aText <Cmd>echo mode(1)<CR> Added<Esc>

不像<expr>映射, <Cmd>命令没有特殊的限制: 它就像一个(无限制)|autocommand|被执行
一样被执行. 

						*<ScriptCmd>*
<ScriptCmd>和<Cmd>类似但在命令执行期间会将上下文设置为映射被定义的脚本.
这在|Vim9|中是尤其有用的.
在插件中使用(可能是自动加载的)脚本用于访问导入是有效的. >
	vim9script
	import autoload 'implementation.vim' as impl
	nnoremap <F4> <ScriptCmd>impl.DoTheWork()<CR>
<
无论<F4>在哪被键入, "impl"导入都会在映射被定义的脚本上下文中被找到.像例子中映射
自动导入时, "implementation.vim"只会在<F4>被键入时载入, 而不是映射被定义时.

映射使用脚本变量"s:impl"不用<ScriptCmd>会导致"E121: Undefined variable"错误. 

注意: 
- 因为<Cmd>及<ScriptCmd>不会改变模式,所以命令不会触发|CmdlineEnter||CmdlineLeave|
  事件, 因为参数涉及并不希望进行用户交互. 
- 同样的原因, 像<C-R><C-W>的键位码|keycodes|会被解释为普通的、未被映射的按键. 
- 不需要使用<silent>因为命令的执行不会被回显. 
- 右值序列不会应用缩写及其他映射, 即便映射是递归的. 
- 在可视模式中可以使用`line('v')`及`col('v')`获取可视区域的一端, 光标处于另一端.

							*E1255* *E1136*
<Cmd>及<ScriptCmd>命令必须终止, 也就是说, 它们必须在映射定义的右值序列中以<CR>
结尾. 映射不会切换到|Command-line|模式.在右值序列中使用|<lt>|代替<CR>的字面量. 


1.3 映射及模式						*:map-modes*
			*mapmode-nvo* *mapmode-n* *mapmode-v* *mapmode-o*

Vim有七种映射集
   MODE			触发行为
- 普通模式       : 键入命令
- 可视模式       : 当可视区域被高亮时键入命令
- 选择模式       : 类似可视模式但键入的文本会替换选区内容
- 操作符待定模式 : 当在等待操作符输入时 (在"d", "y", "c"等命令之后).
		   查阅下面的|omap-info|. 
- 插入模式	 : 这些映射也会被应用于替换模式
- 命令行模式	 : 键入":"或"/"命令
- 终端模式	 : 在|:terminal|缓冲区输入内容

特殊情况: 当在普通模式键入命令的执行次数时, 映射0会被禁止.这样才能映射0而不影响
输入带有0的命令执行次数.

						*map-overview* *map-modes*
映射命令应用的模式预览. 后面有更多的细节. 
     COMMANDS                    MODES ~
:map   :noremap  :unmap     Normal, Visual, Select, Operator-pending
:nmap  :nnoremap :nunmap    Normal
:vmap  :vnoremap :vunmap    Visual and Select
:smap  :snoremap :sunmap    Select
:xmap  :xnoremap :xunmap    Visual
:omap  :onoremap :ounmap    Operator-pending
:map!  :noremap! :unmap!    Insert and Command-line
:imap  :inoremap :iunmap    Insert
:lmap  :lnoremap :lunmap    Insert, Command-line, Lang-Arg
:cmap  :cnoremap :cunmap    Command-line
:tmap  :tnoremap :tunmap    Terminal-Job

表格形式: 
							*map-table*
         Mode  | Norm | Ins | Cmd | Vis | Sel | Opr | Term | Lang | ~
Command        +------+-----+-----+-----+-----+-----+------+------+ ~
[nore]map      | yes  |  -  |  -  | yes | yes | yes |  -   |  -   |
n[nore]map     | yes  |  -  |  -  |  -  |  -  |  -  |  -   |  -   |
[nore]map!     |  -   | yes | yes |  -  |  -  |  -  |  -   |  -   |
i[nore]map     |  -   | yes |  -  |  -  |  -  |  -  |  -   |  -   |
c[nore]map     |  -   |  -  | yes |  -  |  -  |  -  |  -   |  -   |
v[nore]map     |  -   |  -  |  -  | yes | yes |  -  |  -   |  -   |
x[nore]map     |  -   |  -  |  -  | yes |  -  |  -  |  -   |  -   |
s[nore]map     |  -   |  -  |  -  |  -  | yes |  -  |  -   |  -   |
o[nore]map     |  -   |  -  |  -  |  -  |  -  | yes |  -   |  -   |
t[nore]map     |  -   |  -  |  -  |  -  |  -  |  -  | yes  |  -   |
l[nore]map     |  -   | yes | yes |  -  |  -  |  -  |  -   | yes  |


    COMMANDS				      MODES ~
				       Normal  Visual+Select  Operator-pending ~
:map   :noremap   :unmap   :mapclear	 yes	    yes		   yes
:nmap  :nnoremap  :nunmap  :nmapclear	 yes	     -		    -
:vmap  :vnoremap  :vunmap  :vmapclear	  -	    yes		    -
:omap  :onoremap  :ounmap  :omapclear	  -	     -		   yes

:nunmap can also be used outside of a monastery.	`领略下作者的风骚`
						*mapmode-x* *mapmode-s*
一些命令同时适用可视模式和选择模式, 一些只适用其中一个. 注意, 在可视模式和选择
模式应用映射时会经常提及"Visual". |Select-mode-mapping|
注意: 在选择模式中映射可打印字符可能会困惑用户. 可打印字符最好是显式的使用
      :xmap 和 :smap 并且在取消映射时使用 :sunmap >
  这里的内容是按译者自己的理解修改的, 具体内容查看英文文档
<

    COMMANDS				      MODES ~
					  Visual    Select ~
:vmap  :vnoremap  :vunmap  :vmapclear	    yes      yes
:xmap  :xnoremap  :xunmap  :xmapclear	    yes       -
:smap  :snoremap  :sunmap  :smapclear	    -	     yes

			*mapmode-ic* *mapmode-i* *mapmode-c* *mapmode-l*
一些命令同时适用插入模式和命令行模式, 一些只适用其中一个: 

    COMMANDS				      MODES ~
					  Insert  Command-line	Lang-Arg ~
:map!  :noremap!  :unmap!  :mapclear!	    yes	       yes	   -
:imap  :inoremap  :iunmap  :imapclear	    yes		-	   -
:cmap  :cnoremap  :cunmap  :cmapclear	     -	       yes	   -
:lmap  :lnoremap  :lunmap  :lmapclear	    yes*       yes*	  yes*

* If 'iminsert' is 1, see |language-mapping| below.

原先的Vi并不区分普通模式、可视模式、操作符待定模式、插入模式及命令行模式的映射. 
因此":map"及":map!"命令可以执行并显示多个模式的映射. 在Vim中可以使用":nmap", 
":vmap", ":omap", ":cmap" 及":imap" 为每个模式单独设置映射. 

							*mapmode-t*
终端映射用于在终端中键入命令执行任务的终端窗口.	      查阅文档|terminal-typing|

							*omap-info*
操作符待定映射可以用于定义用于任意操作符的移动命令. 简单的例子: >
	:omap { w
这会让"y{"像"yw"、"d{"像"dw"一样的作用

可以让omap用可视模式选择要操作的文本以忽视光标开始位置及选择不同的文本.比如操作
当前行的函数名称: >
	onoremap <silent> F :<C-U>normal! 0f(hviw<CR>
CTRL-U(<C-U>)被用来移除Vim可能插入的范围. 普通模式命令找到第一个'('字符并选择
其前面的一个单词. 那通常是一个函数名称. >
  这里举得例子局限性很大, 仅用于解释这种操作理念

可以先定义多种模式的映射然后在取消相应模式的映射以实现灵活的映射设置. 如先定义
普通模式、可视模式及操作符待定模式的映射, 然后再取消操作符待定模式的映射以实现
对普通模式及可视模式的映射: >
	:map    xx something-difficult
	:ounmap xx

这样的组合方式也适用于其他的映射命令. 

						*language-mapping*
":lmap" 定义的命令可应用于: 
- 插入模式
- 命令行模式
- 键入搜索模式的时候
- 接受文本字符作为参数的命令, 比如"r"和"f"
- 用于input()行
通常来说: 无论何时字符被输入它都是缓冲区文本的一部分而不是Vim命令字符.
"Lang-arg"并不是真的存在这个模式, 它只是在满足条件的情况下被适用. 
   加载相关语言的映射集最简单的方式是适用'keymap'选项. 查阅文档|45.5|. 
   在插入模式及命令行模式中, 映射可以被CTRL-^命令|i_CTRL-^| |c_CTRL-^|禁止.
这些命令会改变'iminsert'选项的值. 当开始输入普通命令时 (不是搜索模式) 映射会被
禁止直到CTRL-^再次被输入. 之前的状态会在插入模式和搜索模式中被分别的记录. 
插入模式的状态也会在输入字符作为像"f"或者"t"命令的参数时被使用. 
   语言映射不会应用于已经被映射的字符. 这会认为在键入映射时已经完成语言映射了. 


1.4 罗列映射						*map-listing*

当罗列映射时, 列表的前两列字符应该是下面这些: 

      CHAR	MODE	~
     <Space>	Normal, Visual, Select and Operator-pending
	n	Normal
	v	Visual and Select
	s	Select
	x	Visual
	o	Operator-pending
	!	Insert and Command-line
	i	Insert
	l	":lmap" mappings for Insert, Command-line and Lang-Arg
	c	Command-line
	t	Terminal-Job

在右值序列前面还可能出现特殊的字符: 
	*	indicates that it is not remappable
	&	indicates that only script-local mappings are remappable
	@	indicates a buffer-local mapping

左值序列之后的第一个非空字符到行结束 (或'|')之间的一切内容都会被认为是右值序列
的内容. 这允许右值序列以空格结束. 

注意: 当为可视模式使用映射时,可视使用"'<"(这是当前缓冲区上次被选择的可视区域的
开始位置)标记.								|'<|

|:filter|命令可以用来选择要列出的映射. 模式会与左值序列或右值序列的原始格式进行匹配

							*E1309*
当映射被列出时, 添加或清除映射都将失效, 比如, 在计时器回调函数中添加或清除映射. 

							*:map-verbose*
当'verbose'选项为非零值时, 被探测和使用的'keyprotocol'值会被显示在第一行.然后是
键位映射, 再之后就是显示最后被定义的位置. 比如: >

	:verbose map <C-W>*
	Kitty keyboard protocol: Cleared
	n  <C-W>*      * <C-W><C-S>*
		Last set from /home/abcd/.vimrc

查阅文档|:verbose-cmd|获取更多的信息


1.5 映射特殊按键					*:map-special-keys*

有三种方式映射特殊按键: 
1. Vi兼容方式: 映射按键编码. 这通常是以<Esc>开始的序列. 用这种方式映射需要键入
   :map然后在键入特殊按键(如功能键)之前键入CTRL-V. 注意:
   当按键的编码在termcap('t_'选项)中时,它会自动被转换为内部编码并使用第二种映射
   方式(除非'k'标识符出现在'cpoptions'中).
2. 第二种方式是用功能键的内部编码.用这样的方式映射需要键入CTRL-K然后键入特殊按键
   或使用"#1", "#2", .. "#9", "#0", "<Up>", "<S-Down>", "<S-F7>"等形式.  (查阅
   按键表|key-notation|, 所有来自<Up>组的按键均可使用).前面10种功能键有两种定义
   形式: 数字定义(像"#2")及"<F>"前缀定义(像"<F2>"). 两者都表示功能键2."#0"表示
   功能键10, 被定义为选项't_10'(在某些键盘上可能是功能键0). 当'cpoptions'包含
   '<'标识符时 <>形式的定义就会失效. 
3. 使用termcap接口 (采用<t_xx>形式, "xx"时termcap的接口名). 任意的接口字符都能
   使用. 比如: >
      :map <t_F3> G
<  映射功能键13到"G"键. 如果'cpoptions'包含'<'标识符时这种定义方式不会生效. 

第二种和第三种方法的优势是映射在各终端都是通用的(功能键会被翻译为一样的内部编码
或真实的按键编码, 与使用的终端无关. 这样定义映射有效的前提是termcap是正确的并且
必须使用相同的映射) 

细节:Vim首先会检查来自键盘的序列是否被映射.如果没有被映射则会尝试终端按键编码.
(查阅文档|terminal-options|). 如果终端按键编码被找到则会将之替换内部编码. 然后
再次检查映射是否被完成 (因此可以映射内部编码到一些其他的功能上).被写入到buffer
的内容取决与被识别的内容. 如果终端按键编码被识别为映射则按键编码本身会被写入到
buffer中). 如果输入被是被为终端编码则内部编码会被写入到buffer中. 


1.6 特殊字符					*:map-special-chars*
						*map_backslash* *map-backslash*
注意只有在这里提及的CTRL-V被视为映射及缩写的特殊字符. 当'cpoptions'不包含'B'时, 
反斜杆与CTRL-V有同样的作用. 之后可以完全使用<>标记 |<>|. 但是不能像CTRL-V那样
使用"<C-V>"转义后续输入的特殊意义. >
  译者注: 这里指的时必须使用vim的命令CTRL-V对特殊按键进行转义, 而<C-V>只是表示
  一个特殊键, 这显然是不行的

可以使用特殊序列<Bslash>映射反斜杠或在右值序列中使用反斜杠字面量.
这避免了在嵌套映射时使用双反斜杠.

						*map_CTRL-C* *map-CTRL-C*
可以在左值序列中使用CTRL-C, 但这只会在vim等待按键输入时有效, vim在处理任务时则
会导致命令中断. 
当在windows上适用GUI版本时, CTRL-C可以被映射为允许复制命令复制内容到剪切板.
适用CTRL-Break则会中断Vim. 

					*map_space_in_lhs* *map-space_in_lhs*
可以使用CTRL-V (为每个空格按两次CTRL-V) 让右值序列包含空格. 
					*map_space_in_rhs* *map-space_in_rhs*
如果想让右值序列以空格开始, 可以使用"<Space>". 至于Vi完全兼容模式(不可读)则不能
使用|<>|标记, 只能使用CTRL-V+空格的形式 (需要键入CTRL-V两次) >
  译者注: 支持|<>|vim在左值序列和右值序列都可以使用<Space>, 如果不支持|<>|则需
  为每个空格按两次CTRL-V, 这是因为|c_CTRL-V|会将后续字符的字面量作为输入的部分
  而不会去解析它的作用. 
<
						*map_empty_rhs* *map-empty-rhs*
可以通过键入单个CTRL-V(按下两次CTRL-V, 无字符随后)创建空右值序列. 这个方法不能
在vimrc文件中使用. >
  这里依然是是利用了|c_CTRL-V|的作用, 在命令模式右值序列无后续字符会被自动转
  换为<Nop>, 但在vimr中, 后面其实是有(<NL>)字符的, 这导致Vim将<NL>连同下
  一行都作为右值序列的内容, 即便该映射放在文件最后一行,只是文件下一行的内容为空
<
							*<Nop>*
创建空右值序列的方法是使用"<Nop>", 这只在支持|<>|标记时有效. 比如, 确保功能键
<F8>不产生任何作用: >
	:map  <F8>  <Nop>
	:map! <F8>  <Nop>
<
							*map-multibyte*
映射命令也能映射多字节字符, 但只能是整个字符而不能映射其中的某个字节. 这被用来
在下面的场景避免问题: >
	:set encoding=latin1
	:imap <M-C> foo
	:set encoding=utf-8
按键<M-C>被定义为拉丁文编码, 其字符编码为0xc3(Ã), 然后再输入一个字符á, 这个字符
在latin1字符集中编码为0xe1(快捷键为<M-a>), 但在UTF-8字符集中编码为0xc3 0xa1,
占用两个字节, 并且第一个字节对应latin1字符集中的Ã, 如果多字节字符编码的第一个
字节被映射的话, 那就无法输入这个字符了. >
  这里解释的有点复杂, 就是说如果多字节字符被映射时, 它只会处理整个字符的编码, 
  而不是把字符的编码字节单独处理, 单独处理字节会产生很多意外问题, 且意义不明
	比如: imap 法克 fuck|在插入模式中输入法克时会被自动替换为fuck,
	其中法克在UTF-8中的编码为E6B395E5858B, 这意味着Vim只会处理整个字符编码
	序列而不会将其拆开处理. 
  另注: latin1是ISO-8859-1字符集的别名.
<
					*<Leader>* *mapleader*
特殊字符串"<Leader>"可以用来定义使用"g:mapleader"变量的映射. 它会被"g:mapleader"
的字符串值给替换. 如果"g:mapleader"没有被设置或为空, 则会默认使用反斜杠代替.
如: >
	map <Leader>A  oanother line<Esc>
与下列映射效果一样: >
	map \A  oanother line<Esc>
但在定义之后 (旧版脚本): >
	let mapleader = ","
或 (Vim9脚本): >
	g:mapleader = ","
上面的定义就变成了: >
	map ,A  oanother line<Esc>

注意"g:mapleader"的值会在定义映射的时候被使用. 这之后修改"g:mapleader"将不会影响
已经定义的映射. 

					*<LocalLeader>* *maplocalleader*
除了使用"maplocalleader"代替"mapleader"之外<LocalLeader>和<Leader>类似. 
<LocalLeader>被用于缓冲区局部映射. 比如: >
      :map <buffer> <LocalLeader>A  oanother line<Esc>
<
应该在全局插件中使用<Leader>而在文件类型插件中使用<LocalLeader>. "mapleader"及
"maplocalleader"可以是相同的. 虽然全局映插件映射可能与文件类型插件冲突,
将<Leader>和<LocalLeader>设置为不同的值可降低这种情况. 例如, 可以包持"mapleader"
为默认的反斜杠并设置"maplocalleader"为下划线. 

							*map-<SID>*
脚本中的特殊键名"<SID>"可以被用来定义脚本的局部映射.	更多细节查阅文档|<SID>|

							*<Plug>*
特殊键名"<Plug>"可以被用于内部映射, 这不会被任何按键序列匹配. 这在插件中很有效. 
|using-<Plug>|. 

							*<MouseMove>*
特殊键名"<MouseMove>"可以被用于处理鼠标移动.这需要开启'mousemoveevent'选项当前
只在GUI中有效. 函数|getmousepos()|可以被用于获取鼠标位置信息. 

							*<Char>* *<Char->*
可以使用<Char>构造可以用来通过十进制、八进制或十六进制编码映射字符: 
	<Char-123>	character 123
	<Char-033>	character 27
	<Char-0x7f>	character 127
	<S-Char-114>    character 114 ('r') shifted ('R')
这在'keymap'文件中指定 (多字节) 字符是很有效的. 映射编码不区分大小写. 

							*map-comments*
在这里映射命令后面添加注释是不可行的, 因为'"'字符会被认为是左值序列或右值序列中
的一部分. 然而, 可以使用 |" 进行注释, 因为这启动了一个新的、带注释的空白命令. 

							*map_bar* *map-bar*
由于'|'字符被用来分隔映射命令及后续命令, 这需要做一些其他设置让右值序列包含'|', 
总共有三种方法: 
   use	     works when			   example	~
   <Bar>     '<' is not in 'cpoptions'	   :map _l :!ls <Bar> more^M
   \|	     'b' is not in 'cpoptions'	   :map _l :!ls \| more^M
   ^V|	     always, in Vim and Vi	   :map _l :!ls ^V| more^M

(这里的代表CTRL-V; 可通过按两次CTRL-V获取这个字符字面量; 不能使用<>标记<C-V>)

当使用'cpoptions'选项默认设置时, 三种方法都有效. 

当'cpoptions'有'b'标识符时, "\|"将会被识别为以'\'结尾的映射然后接着是另一个命令.
这是兼容Vi的设置, 但这与其他命令比起来不符合逻辑. 

						*map_return* *map-return*
当定义一个包含Ex命令的映射时, 需要放置一个行终止符以让它被执行. 推荐使用<CR>, 
 (查阅文档|<>|). 比如: >
   :map  _ls  :!ls -l %:S<CR>:echo "the end"<CR>

为了避免在插入模式或命令行模式中输入的字符被映射, 可以先输入CTRL-V. 如果'paste'
选项开启的话, 插入模式中的映射将会被禁止. 
							*map-error*
注意当遭遇到错误时 (可能导致错误消息或导致蜂鸣) 剩下的映射则不会被执行.
这是兼容Vi的. 

注意这些命令 (@zZtTfF[]rm'`"v及CTRL-X) 的第二个字符 (参数) 不会被映射.
这是为了能够使用所有的具名寄存器及标记, 即便命令映射了相同名称的命令. 


1.7 被映射的键						*map-which-keys*

如果要映射一些内容, 首先需要选择用于左值序列的按键. 这需要避开用于vim命令的那些
按键, 不然这些命令将不能被再次使用. 下面是一些建议: 
- 功能键<F2>, <F3>, etc.. 以及使用shift修饰符的功能键<S-F1>, <S-F2>, etc.
  注意: <F1>已经用于帮助命令了. 
- 以Alt或Meta键修饰的任意键. 取决于你的键盘, 重音字符可能也能被使用. 
  |:map-alt-keys|
- 使用'_'或','+其他字符的组合. "_"及","命令在Vim中是存在的(查阅|_|及|,|), 但是
  有可能从未被使用. 
- 使用另一个命令的同义词. 比如: CTRL-P和CTRL-N. 使用额外的字符以允许更多的映射. 
- 用<Leader>定义的按键及一个或多个其他按键. 这在脚本中是特别有效. |mapleader|

查看"index"文件获取那些没被使用的按键, 这样就能在不丢失任何内置功能的情况被映射
也可以使用":help {key}" 查找那些被定义的按键.  ({key}是想要查找的特殊按键,
则是CTRL-D  |c_CTRL-D|) 


1.8 映射样例						*map-examples*

少量的例子 (正如给的那样键入, 对于"<CR>", 需要键入4个字符; "<"标志不能出现在选项
'cpoptions'中以让这些例子生效). >

   :map <F3>  o#include
   :map <M-g> /foo<CR>cwbar<Esc>
   :map _x    d/END/e<CR>
   :map! qq   quadrillion questions


Multiplying a count(应用计数)

当在触发映射前面输入一个计数时就像在左值序列前面输入一个计数. 比如下面这个映射: >
   :map <F4>  3w
键入2<F4>会导致"23w". 因此这会让光标前移23个单词而不是2 * 3个单词. 如果想要应用
计数, 可以使用表达式寄存器: >
   :map <F4>  @='3w'<CR>
引号之间的部分是被执行的表达式. |@=|


1.9 USING MAPPINGS					*map-typing*

Vim会比较键入的字符和被映射序列的开始. 如果没玩完全匹配则它会继续获取更多的字符
直到要么完全匹配要么没有匹配项. 比如: 如果映射"qq", 第一个字符'q'不会出现在屏幕
上直至键入了另一个字符. 这是因为Vim不知道下个字符是否为'q'. 如果启用'timeout'选
项(默认启用)Vim将只会等待1秒 (或者是'timeoutlen'选项指定的时间). 之后则假设'q'
应该被应用. 如果输入缓慢或者系统运行很慢, 重置'timeout'选项, 之后可能需要设置
'ttimeout'选项. 

							*map-precedence*
Buffer相关映射 (使用|:map-<buffer>|定义的) 的优先级高于全局映射. 当buffer相关
映射与全局映射一样时, Vim将会使用buffer相关映射. 此外, 如果映射通过<nowait>定义
则vim会在匹配映射之后立马使用, 即便更长的映射拥有一样的前缀. 比如, 下面给出的
两个映射: >
    :map <buffer> <nowait> \a   :echo "Local \a"<CR>
    :map                   \abc :echo "Global \abc"<CR>
当键入\a时buffer相关映射会被立马使用. Vim不会再等其他字符以确定用户是否会键入\abc

							*map-keys-fails*
存在键位编码可能不被识别的情况: 
- Vim只能读取部分键位编码. 大多数是只读第一个字符. 这发生在一些unix般的的xterm. 
- 键位编码位于被映射字符的后面. 比如 "<F1><F1>" 或者"g<F1>" 

结果就是键位编码在这种情况下不被识别, 且映射失效. 需要两个步骤避免这个问题. 

- 移除'cpoptions'中的'K'标识符. 这会让Vim等待功能键之后的字符. 
- 当使用<F1>到<F4>时生成的真实的键位编码可能是<xF1>到<xF4>. 存在<xF1>到<F1>, 
  <xF2>到<F2>, 等映射, 但是这些在映射的剩余内容中不被识别. 确保<F1>到<F4>的键位
  编码是正确的. >
	:set <F1>=<type CTRL-V><type F1>
< 键入4字符形式<F1>. "="之后的部分则必须使用真实按键, 而不是字面量文本. 
另一个解决方法是在映射第二个特殊按键时使用真实键位编码: >
	:map <F1><Esc>OP :echo "yes"<CR>
不要键入真的<Esc>, 总之Vim会识别键位编码并使用<F1>替换<Esc>OP. >
  终端下的<Esc>可能是OP (即<Esc>OP), 这里的后半部分就是F1在Vim内部的形式

另一个问题可能是当保持ALT或Meta键按下的时候,终端可能会增加ESC前缀而不是
设置第8位比特位. 查阅文档|:map-alt-keys|.

						*recursive_mapping*
如果右值序列中包含左值序列, 这就定义了一个递归映射. 当左值序列被键入时, 它会被
右值序列替换, 并反复进行. 这可能导致无限次重复命令. 唯一的问题是终止命令的唯一
方法是抛出一个错误. 解决迷宫问题的宏就使用了这个特性, 去那查找一些例子. 存在一处
例外: 如果右值序列以左值序列开始, 则第一个字符不会被再次映射 (这是Vi兼容的). 
比如: >
   :map ab abcd
映射将会执行"a"命令并插入"bcd"到文本中. 右值序列中的"ab"将不会被再次映射. 

如果想要交换两个按键的意义, 则应该使用:noremap命令. 比如: >
   :noremap k j
   :noremap j k
这会交换光标移动的命令. 

当'remap'选项启用时, 正常的:map命令映射会一直替换直到被找到的文本不是左值序列. 
比如, 如果使用: >
   :map x y
   :map y x
Vim会反复进行y替换x, x替换y. 当替换次数达到'maxmapdepth'次(默认值1000)时, Vim将
会抛出一个"recursive mapping"错误消息. 

							*:map-undo*
如果被映射的序列中包含撤销命令, 这将会使文本回到执行宏之前的状态. 这与原来的Vi
是兼容的, 只要被映射的序列中仅包含一个撤销命令, 这种情况就会发生(在原来的Vi中包
含两个撤销命令是无意义的, 这只会让文本回到第一个撤销操作的状态)


1.10 映射ALT按键					*:map-alt-keys*

可以使用<A-k>形式确保映射命令的可读性. 注意<A-k>即<A-K>是不同的, 后者会采用大写
字母. 事实上, <A-K>和<A-S-K>是一样的. 如果键盘上有Meta修饰键可以使用"M"代替"A".
查阅文档|:map-meta-keys|. 

在GUI中Vim会自己处理Alt键, 因此映射带ALT的按键应该总是有效的. 但在终端中Vim获取
字节序列并且需要确认ALT键位是否被按下. 

如果终端支持修饰键模式且特性被启用时, Vim就能识别更多的按键组合, 查阅下面的
|modifyOtherKeys|.Kitty键盘协议以相似的方式工作,查阅文档|kitty-keyboard-protocol|

默认Vim假定按ALT键设置键入字符的第8个比特位. 大多数体面的终端可以用这方式生效, 
比如xterm, aterm及rxvt. 如果<A-k>映射不生效那可能是终端用一个ESC字符作为被映射
字符的前缀. 但是这样在字符前输入ESC也是可行的, 因为Vim不知道发生了啥 (除了检查
字符输入期间的延迟, 这是不可靠的). 

就像文档描写的这样, 一些主流的终端像gnome-terminal及konsole使用ESC前缀. 这就没
办法使用通过使用第8位比特位设置ALT按键. Xterm默认应该工作的很好. Aterm及rxvt应
该会在以"--meta8"参数启动时工作正常. 可以调整像"metaSendsEscape", 
"eightBitInput" and "eightBitOutput"的资源实现这样的功能. >
  现在Vim内部标识ALT键的按钮都是通过(ESC), 可以通过CTRL-V查看

在Linux控制台, 这个行为可以通过"setmetamode"命令切换. 牢记不适用ESC前缀可能会让
你在使用其他程序时碰见问题. 应当确保bash开启了"convert-meta"以让Meta按键绑定仍
能工作. (默认readline行为, 除非被特定系统配置所修改).可以添加下面一行到~/.inputrc
文件使用这个功能: >

	set convert-meta on

如果正在创建这个文件, 如果/etc/inputrc在系统中存在, 想要保留全局选项的话则需要
添加下面这一行作为文件的第一行: >

	$include /etc/inputrc

这可能在输入特殊字符时导致问题, 比如umlaut (元音字符). 然后就需要在字符前使用
CTRL-V. 

记住, convert-meta用于本地UTF-8字符集时已经被提交过问题. 在像xterm的终端上, 
"metaSendsEscape"选项可以通过Ctrl-LeftClick打开"Main Options"菜单进行切换;
这是最后的好方法以防在使用其他应用而不是在Vim中时想要使用ESC键.  


1.11 映射META按键					*:map-meta-keys*

映射带有Meta修饰键的序列与使用Alt按键是相似的. 键盘使用哪个按键作为Meta键取决于
键盘及配置. 

注意: 映射<M-a>事实上是使用Alt键. 这很令人困惑, 但这不能被修改否则不能向后兼容. 

至于Meta修饰键则使用"T". 比如, 在插入模式中映射Meta-b: >
	:imap <T-b> terrible

1.12 映射SUPER按键或COMMAND按键		      *:map-super-keys* *:map-cmd-key*

Super修饰键在Linux的gVim或Mac OS的MacVim的GUI模式中是可用的 (当|gui_running|为1) 
如果正在使用Mac系统, 这就是Command按键, 在使用GTK GUI的linux则是Super按键.
字符"D"用来表示Super/Command修饰键. 

比如, 在插入模式中映射Command-b: >
	:imap <D-b> barritone

1.13 在modifyOtherKeys模式中映射      			*modifyOtherKeys*

Xterm及少部分其它终端可以使用一个带修饰键的按键被表示为带ESC编码的模式. Vim识别
这些编码然后区分CTRL-H及退格符, 即使当退格符发送字符8(这里指的是退格符ASCII:8)
并且许多更多的特殊按键, 比如Tab及CTRL-I, 在其他模式中不能被单独映射. 

在xterm中modifyOtherKeys在内置termcap接口中是开启的. 如果这个选项没被开启, 可以
在vimrc中添加下列几行开启这个功能: >
      let &t_TI = "\<Esc>[>4;2m"
      let &t_TE = "\<Esc>[>4;m"
这将会设置modifyOtherKeys为级别2. 注意modifyOtherKeys级别1不会生效. 有些终端不
支持级别2, 之后发送键位编码将不会被Vim正确识别. 

以防modifyOtherKeys模式导致问题, 可以禁用这个选项: >
      let &t_TI = ""
      let &t_TE = ""
这并不会立即生效. 可以通过执行脚本命令让Vim在不重启的情况下生效, 如: `!ls`或者
将这些内容放到|vimrc|中. 

当modifyOtherKeys选项启用时, 可以映射<C-[>及<C-S-{>: >
	imap <C-[> [[[
	imap <C-{> {{{
不启用modifyOtherKeys选项, <C-[>及<C-{>就无法从Esc中被区分出来. >
  <Esc>的字面量即CTRL-[,CTRL-{也可以用来生成<Esc>的键位编码, 但当在键盘上同时
  按下CTRL-[或CTRL-{时, Vim究竟该将其识别为CTRL-[/CTRL-{还是<Esc>呢? 这就是
  modifyOtherKeys存在的意义. 
注意被使用的是<C-{>而不是<C-S-[>或<C-S-{>. 这在大多数键盘上都有效. 类似的, 
<C-}>也被用来代替<C-S-[>或<C-S-{>, <C-|> 代替 <C-S-\> 或 <C-S-|>. 
注意: '|'在映射中具有特殊含义, 查阅文档|map-bar|

警告: 映射<C-[>可能恰巧破坏一些以Esc开头的键位编码. 确保这个操作在其他映射之后

在版本377的xterm中启动Vim会请求modifyOtherKeys状态并识别它, 't_RK'termcap 接口
选项就是用来做这事的. 当响应被找到后Vim就知道modifyOtherKeys级别2是否被启用, 
然后正确的处理映射. 

而在版本377之前, Vim自动检测, 如果modifyOtherKeys模式被启用, 当发现转义序列时
那就一定是通过modifyOtherKeys创建的. 使用`:verbose map`查看Vim是否检测到这样的
转移序列, 如果被检测到那第一行就会显示"Seen modifyOtherKeys:true"(可能会被翻译)

这个自动检测取决于接受到的以"<1b>[27;"开始的转义编码序列. 这是xterm发送这些键位
编码的正常行为. 然而, 如果*formatOtherKeys* 被设置成其他形式并被采用时, Vim就无
法识别这些了, 因此千万不要设置 formatOtherKeys. 

一个已知的副作用是在插入模式中在输入CTRL-V按键之后原始的转义序列会被插入.这可以
用来检查modifyOtherKeys是否被启用: 在插入模式键入CTRL-SHIFT-V CTRL-V, 如果得到
一个字节则modifyOtherKeys是关闭的, 如果得到了<1b>[27;5;118~那就是开启的. >
  注意终端的CTRL-SHIFT-V行为, 这往往会覆盖Vim的行为.	    |i_CTRL-SHIFT-[VQ]|
  实测操作之后获取的是 (一个字节), 这应该是版本迭代之后优化了即Vim能识别<Esc>
  但是具体内容在Vim内部, 用户只能看到最终的操作结果. 

注意在版本376的xterm上有个bug, 这导致Shift-Esc发送了一个常规的Esc编码, 修饰键
Shift被抛弃了. 

当'esckeys'选项被关闭时, 插入模式中modifyOtherKeys将会被禁止以避免带有修饰键的
按键导致退出插入模式. 


1.14 满足KITTY键盘协议的映射			*kitty-keyboard-protocol*

如果'term'选项的值包含"kitty", Vim就会发送一个转义序列启动Kitty键盘协议. 这可以
被'keyprotocol'选项修改. 

就像modifyOtherKeys, 这也能区分带有修饰键的按键. 并且, 协议会为Esc键发送一个
转义序列, 因此Vim不需要使用计时就可以知道接收到的Esc字符是通过Esc按键生成的或是
转义序列的开始字符. 

Vim会在发现状态请求的响应时自动检测Kitty键盘协议是否被启用.
(这应该是|t_TI|termcap接口的部分)使用下面命令查看Vim是否检测到这样的转义序列: >
	:verbose map
第一行将会显示"Kitty keyboard protocol: {value}"(可能会被翻译). 值的意义如下:
	Unknown		no status received yet(还未接收到状态)
	Off		protocol is not used(协议未启用)
	On		protocol is used(协议已启用)
	Disabled	protocol was used but expected to have been disabled
			by 't_TE'(协议启用但被't_TE'选项禁止)
	Cleared		protocol expected to have been disabled by 't_TE',
			previous state is unknown
			(协议被't_TE'选项禁止,前置状态未知)


1.15 映射操作符						*:map-operator*

操作符被用在{motion}命令之前. 自定义操作符必须创建一个先设置'operatorfunc'选项,
然后调用|g@|操作符的映射. 在用户键入{motion}命令之后, 指定函数将会被调用. 

							*g@* *E774* *E775*
g@{motion}		调用由'operatorfunc'选项设置的函数. '[标记指向{motion}
			移动范围的文本开始位置, ']标记则是文本的最后一个字符. 
			函数被调用时带有一个字符串参数(即'opfunc'选项接受一个单
			参函数, 并在调用时自动传参): 
			    "line"	{motion} was |linewise|
			    "char"	{motion} was |characterwise|
			    "block"	{motion} was |blockwise-visual|
			{motion}的类型可以被强制转换, 查阅文档|forced-motion|
			{编译时不带|+eval|特性则不被支持}

下面是一个使用<F4>计算空格数量的例子: >

	nnoremap <expr> <F4> CountSpaces()
	xnoremap <expr> <F4> CountSpaces()
	" doubling <F4> works on a line
	nnoremap <expr> <F4><F4> CountSpaces() .. '_'

	function CountSpaces(context = {}, type = '') abort
	  if a:type == ''
	    let context = #{
	      \ dot_command: v:false,
	      \ extend_block: '',
	      \ virtualedit: [&l:virtualedit, &g:virtualedit],
	      \ }
	    let &operatorfunc = function('CountSpaces', [context])
	    set virtualedit=block
	    return 'g@'
	  endif

	  let save = #{
	    \ clipboard: &clipboard,
	    \ selection: &selection,
	    \ virtualedit: [&l:virtualedit, &g:virtualedit],
	    \ register: getreginfo('"'),
	    \ visual_marks: [getpos("'<"), getpos("'>")],
	    \ }

	  try
	    set clipboard= selection=inclusive virtualedit=
	    let commands = #{
	      \ line: "'[V']",
	      \ char: "`[v`]",
	      \ block: "`[\<C-V>`]",
	      \ }[a:type]
	    let [_, _, col, off] = getpos("']")
	    if off != 0
	      let vcol = getline("'[")->strpart(0, col + off)->strdisplaywidth()
	      if vcol >= [line("'["), '$']->virtcol() - 1
	        let a:context.extend_block = '$'
	      else
	        let a:context.extend_block = vcol .. '|'
	      endif
	    endif
	    if a:context.extend_block != ''
	      let commands ..= 'oO' .. a:context.extend_block
	    endif
	    let commands ..= 'y'
	    execute 'silent noautocmd keepjumps normal! ' .. commands
	    echomsg getreg('"')->count(' ')
	  finally
	    call setreg('"', save.register)
	    call setpos("'<", save.visual_marks[0])
	    call setpos("'>", save.visual_marks[1])
	    let &clipboard = save.clipboard
	    let &selection = save.selection
	    let [&l:virtualedit, &g:virtualedit] = get(a:context.dot_command ? save : a:context, 'virtualedit')
	    let a:context.dot_command = v:true
	  endtry
	endfunction

一个表达式映射能够被用来获取任意前缀的计数和寄存器. 这也避免了触发CmdlineEnter
和CmdlineLeave自动命令的命令行. 

注意'selection'选项被临时设置未"inclusive"以通过可视模式的'[和']标记复制完全正确
的文本. 

另注意: 如果'clipboard'选项的值包含`unnamed`和`unnamedplus`项则会被临时置空以
避免损毁`"*`和`"+`寄存器(内容). 

`mode()`函数将会返回应用操作符之后的状态. 

下面是用lambda函数创建普通模式在当前行添加引号操作符的例子: >

	nnoremap <F4> <Cmd>let &opfunc='{t ->
				\ getline(".")
				\ ->split("\\zs")
				\ ->insert("\"", col("'']"))
				\ ->insert("\"", col("''[") - 1)
				\ ->join("")
				\ ->setline(".")}'<CR>g@

==============================================================================
2. 缩写					*abbreviations* *Abbreviations*

缩写被用在插入模式、替换模式及命令行模式. 如果输入的单词是缩写, 则会被替换为它
代表的单词. 这可以被用来减少常用长单词的输入. 并且也可以用来纠正明显的拼写错误
比如: >

	:iab ms Microsoft
	:iab tihs this

有三种类型的缩写: 

full-id	  "full-id"类型完全由关键字符组成 (字母和字符来自'iskeyword'选项).这是
	  最常见的缩写. 

	  比如: "foo", "g3", "-1"

end-id	  "end-id"类型以关键字符结尾, 但此外的所有字符不是关键字符. 

	  比如: "#i", "..f", "$/7"

non-id	  "non-id"类型则以非关键字符结尾, 其余字符可以是任意类型, 但不包括空格
	  和制表符. {Vi不支持这个类型}

	  比如: "def#", "4/7$"

不能作为缩写的字符串: "a.b", "#def", "a b", "_$r"

缩写只会在键入非关键字符之后被识别. 这可以是结束插入模式的<Esc>或确认命令的<CR>.
结束缩写的非关键字符会被插入到缩写扩展之后. 用于扩展缩写的字面意义而不插入任何
额外字符的<C-[>是个例外. 

比如: >
   :ab hh	hello
<	    "hh<Space>" 被扩展为 "hello<Space>"
	    "hh<C-]>" 被扩展为 "hello"

光标前面的字符必须匹配缩写, 每种类型都有额外的规则: 

full-id	  In front of the match is a non-keyword character, or this is where
	  匹配项之前是非关键字或者是行起始位置或开始插入位置. 例外: 当缩写只有
	  一个字符时, 如果在这之前有非关键字符而不是空格或指标符时它将不会被识
	  别. 然而, 命令行"'<,'>"(或其他标记)会被忽略, 就像命令行是之后开始的. 

end-id	  匹配项之前是关键字符、空格或制表符或者是行起始位置或插入起始位置.

non-id	  匹配项之前是空格、制表符或行其实位置或插入起始位置.

例子:  ({CURSOR}是键入非关键字符的地方) >
   :ab foo   four old otters
<		" foo{CURSOR}"	  被扩展为 " four old otters"
		" foobar{CURSOR}" 不会被扩展
		"barfoo{CURSOR}"  不会被扩展
>
   :ab #i #include
<		"#i{CURSOR}"	  被扩展为 "#include"
		">#i{CURSOR}"	  不会被扩展
>
   :ab ;; <endofline>
<		"test;;"	  不会被扩展
		"test ;;"	  被扩展为 "test <endofline>"

在会触发缩写的字符前键入CTRL-V可以避免在插入模式中使用缩写. 比如CTRL-V <Space>.
或者键入缩写的一部分然后按<Esc>退出插入模式然后用"a"命令重新进入插入模式并键入
剩余部分. 

在缩写中使用CTRL-V两次以避免在命令行模式中缩写被替换. 否则普通字符前面的CTRL-V
很可能被忽视. 

将光标移动到缩写之后的位置是可行的: >
   :iab if if ()<Left>
如果'cpoptions'包含'<'标识符则不会生效.  |<>|

当然这也能做更多的复杂的工作. 比如, 移除缩写之后键入的空格: >
   func Eatchar(pat)
      let c = nr2char(getchar(0))
      return (c =~ a:pat) ? '' : c
   endfunc
   iabbr <silent> if if ()<Left><C-R>=Eatchar('\s')<CR>

Vim没有默认的缩写. 

缩写不会递归进行. 可以没有任何问题的使用":ab f f-o-o".但是缩写能够被映射. {一些
Vi版本支持递归缩写, 这毫无理由}

如果开启了'paste'选项, 缩写则会被禁止. 

				*:abbreviate-local* *:abbreviate-<buffer>*
就像映射一样, 缩写也可以至于buffer相关. 这通常用于|filetype-plugin|文件. 比如, 
C插件文件: >
	:abb <buffer> FF  for (i = 0; i < ; ++i)
<
						*:ab* *:abbreviate*
:ab[breviate]		列出所有缩写. 第一列的字符表明缩写应用的模式: 'i'对应
			插入模式, 'c'对应命令行模式, '!'则两个模式都应用. 这些
			与映射是相同的, 查阅文档|map-listing|. 

						*:abbreviate-verbose*
当'verbose'是非零值时, 列出缩写的同时也会显示它上次被定义的位置. 比如: >

	:verbose abbreviate
	!  teh		 the
		Last set from /home/abcd/vim/abbr.vim

查阅|:verbose-cmd|获取更多信息. 

:ab[breviate] {lhs}	列出以左值序列开始的缩写, 这可能需要插入CTRL-V(键入两次)
			以避免键入的左值序列被扩展, 因为命令行缩写也会在这里被
			应用. 

:ab[breviate] [<expr>] [<buffer>] {lhs} {rhs}
			给右值序列添加左值序列的缩写. 如果左值序列已经存在的话, 
			它会被新的右值序列替换. 右值序列可以包含空格. 
			为可选参数<expr>参数查阅文档|:map-<expr>|
			为可选参数<buffer>参数查阅文档|:map-<buffer>|

						*:una* *:unabbreviate*
:una[bbreviate] [<buffer>] {lhs}
			从列表中移除左值序列对应的缩写. 如果未找到该缩写则移除
			左值序列匹配右值序列的缩写. 这能移除扩展之后的缩写. 
			可以插入CTRL-V (键入两次) 以避免左值序列本身被扩展. 

						*:norea* *:noreabbrev*
:norea[bbrev] [<expr>] [<buffer>] [lhs] [rhs]
			与":ab"一样, 但不会在右值序列中进行映射. 

						*:ca* *:cab* *:cabbrev*
:ca[bbrev] [<expr>] [<buffer>] [lhs] [rhs]
			与":ab"一样, 但只适用于命令行模式. 

						*:cuna* *:cunabbrev*
:cuna[bbrev] [<buffer>] {lhs}
			和":una"一样, 但只适用于命令行模式. 

						*:cnorea* *:cnoreabbrev*
:cnorea[bbrev] [<expr>] [<buffer>] [lhs] [rhs]
			和":ab"一样, 但只适用于命令行模式且右值序列不会被映射. 

						*:ia* *:iabbrev*
:ia[bbrev] [<expr>] [<buffer>] [lhs] [rhs]
			和":ab"一样, 但只适用于插入模式. 

						*:iuna* *:iunabbrev*
:iuna[bbrev] [<buffer>] {lhs}
			和":ab"一样, 但只适用于插入模式. 

						*:inorea* *:inoreabbrev*
:inorea[bbrev] [<expr>] [<buffer>] [lhs] [rhs]
			和":ab"一样, 但只适用于插入模式且右值序列不会被映射. 

							*:abc* *:abclear*
:abc[lear] [<buffer>]	移除所有缩写

							*:iabc* *:iabclear*
:iabc[lear] [<buffer>]	移除插入模式中的所有缩写. 

							*:cabc* *:cabclear*
:cabc[lear] [<buffer>]	移除命令行模式中的所有缩写. 

							*using_CTRL-V*
在缩写的右值序列中适用特殊字符是可行的. CTRL-V被用于避免大多数的非打印字符的
特殊意义. 需要键入多少个CTRL-V取决于键入缩写的形式. 这同样应用于映射. 下面举个
例子. 

假设要设置<Esc>字符的缩写为"esc". 当在Vim中键入":ab"命令时必须像这样键入:
 (这里的时CTRL-V的字面量而则是<Esc>的字面量) 

键入的内容:    ab esc ^V^V^V^V^V^[

	所有键盘输入都经过引用解释,因此第一个、第三个和第五个可以允许第二个、
	第四个及最后的被输入到命令行. 

看到的内容:    ab esc ^V^V^[

	命令行包含两个真的在之前. 如果选择适用.exrc文件的话, 这就是它应该
	出现在.exrc文件中的形式. 这里的第一个用于引用第二个; :ab命令适用
	作为自己的引用字符, 所以能在缩写中使用空白字符或|字符. :ab命令并不会为
	字符做任何特殊的工作, 因此本身不需要被引用.  (尽管引用是无害的;
	这也是为啥输入7个[不是8个]也能生效) 

被存储为:  esc     ^V^[

	在解析之后, 缩写的短格式 ("esc") 及长格式 (两字符"") 被存在缩写表中
	如果执行不带参数的:ab命令, 这就是这个缩写被显示的样子. 

	之后, 如果用户键入了单词"esc"缩写就会被扩展, 长格式对的解释就像键盘
	键入的那样. 所以让避免让被解析为"exit Insert mode"字符. 对应的会被
	插入到文本中. 

最终被扩展为: ^[ >
  这个例子总共有这几步:
    1.创建缩写		:ab esc 
      这里的特殊字符会被解释特殊含义, 所以需要进行转义
    2.存储缩写		:ab esc 
      经过转义后最终存储在缩写表格中就是这个形式
    3.应用缩写
      因为在应用的过程中特殊的字符仍具有特殊含义, 所以需要保留其字面量, 这里
      依旧使用对进行转义, 但本身也为特殊字符, 所以需要再叠一层. 

[example given by Steve Kirkendall]

==============================================================================
3. 局部映射和函数					*script-local*

当使用多个Vimscript脚本文件时, 存在不同文件使用相同映射和函数名称的危险. 为了
避免这个, 可以把他们设置成脚本局部的. 

						*<SID>* *<SNR>* *E81*
字符串"<SID>"可以被用于映射或菜单. 这要求'cpoptions'选项中不能包含'<'标识符. 
如果要从同样的脚本文件中的映射调用脚本局部函数, 这是很有效的. 当执行映射命令时,
Vim将会用特殊的键值编码<SNR>+独属于脚本的数字+下划线替换"<SID>", 比如: >
	:map <SID>Add
将会定义一个映射"<SNR>23_Add". >
  SID: script id[entification]		SNR: script number reference
  脚本ID				脚本引用编号
当在脚本中定义函数时, "s:"可以作为名称前缀让函数成为脚本局部的(在|Vim9|脚本函数
没有前缀就是脚本局部的). 但当映射在脚本之外被执行时, 它并不知道函数是在哪个脚本
中被定义的. 为了避免这个问题, 可以使用"<SID>"歹意"s:". 定义映射时也会发生同样的
转换. 这允许在映射中定义对函数的调用. 

但局部函数被执行时, 它会运行在它被定义的脚本的上下文中. 这意味着函数定义的新的
函数和映射也能使用"s:"或"<SID>"且使用同样的独特编号就像函数本身之前被定义一样. 
此外, "s:var"脚本局部变量也能被使用. 

当执行自动命令或用户命令时, 它会运行在它被定义的脚本上下文中. 这使得命令能调用
局部函数或使用局部映射. 

以防<SID>的值被用在其不能被正确扩展的上下文中, 可以使用expand()函数: >
	let &includexpr = expand('<SID>') .. 'My_includeexpr()'

否则, 在脚本上下文之外的环境使用"<SID>"是一个错误. 

如果需要获取脚本编号以用于复杂的脚本, 可以使用这个函数: >
	func s:ScriptNumber()
	  return matchstr(expand('<SID>'), '<SNR>\zs\d\+\ze_')
	endfunc

当列出函数和映射时"<SNR>"将会被显示. 这在查找它们被定义的内容时是很有效的. 

|:scriptnames|命令可以被用来查看那些脚本被引用及它们的<SNR>编号. 

这些在编译时不带|+eval|特性时都不可用. 

==============================================================================
4. 用户自定义命令					*user-commands*

定义自己的命令也是可行的. 用户自定义命令能像内置命令一样发挥作用 (它可以使用
范围、参数, 参数可以被补全为文件名称或buffer名称等等), 唯一区别是当命令被执行时,
它会被转换为普通的命令然后被执行. 

对于初学者而言: 先查阅用户手册的|40.2|节. 

					*E183* *E841* *user-cmd-ambiguous*
所有用户定义的命令必须以大写字母开头以避免与内置命令混淆.下面这些内置命令是例外:
	:Next
	:X
它们不能被用于用户定义命令. ":Print"也是已经存在的命令, 但它被废弃了并能被替换.

用户自定义命令的其他字符可以是大写、小写或数字. 当使用数字时, 注意这可能会与
其他采用数值作为参数的命令搞混淆. 比如, 命令":Cc2"可以是不带参数的用户命令":Cc2"
也可以是命令":Cc"带个参数"2". 推荐在命令名称和参数之间放一个空格以避免这些问题.

当使用用户自定义命令时, 命令可以被缩写. 然而, 如果缩写不唯一, 将会触发一个错误.
另外, 内置命令总是会优先生效. 

比如: >
	:command Rename ...
	:command Renumber ...
	:Rena				" Means "Rename"
	:Renu				" Means "Renumber"
	:Ren				" Error - ambiguous
	:command Paste ...
	:P				" The built-in :Print

推荐在脚本中使用用户自定义命令的全名. 

:com[mand]						*:com* *:command*
			列出所有的用户自定义命令. 当列出命令时, 第一列的字符: 
			    !	命令有-bang属性. 
			    "	命令有-register属性.
			    |   命令有-bar属性
			    b	命令是当前buffer的局部命令
			(查阅下面关于属性的详细信息)
			可以用|:filter|命令按命令名称过滤列表中的命令, 比如, 
			列出所有名字中带"Pyth" 的命令: >
				filter Pyth command

:com[mand] {cmd}	理出以{cmd}开始的用户自定义命令

							*:command-verbose*
当'verbose'选项是非零值时, 列表命令时会显示它被定义的位置及所有补全参数.比如: >

    :verbose command TOhtml
<	Name	    Args Range Complete  Definition ~
	TOhtml	    0	 %		 :call Convert2HTML(<line1>, <line2>) ~
	    Last set from /usr/share/vim/vim-7.0/plugin/tohtml.vim ~

查阅|:verbose-cmd|文档获取更多信息.

							*E174* *E182*
:com[mand][!] [{attr}...] {cmd} {repl}
			定义一个用户命令. 命令的名字是{cmd}且它的替换文本是{repl}
			命令的属性(看下面)是{attr}. 如果命令已经存在则报错,
			除非!被指定, 这样命令就会被重定义. 有一个列外: 当再次
			引用脚本时, 脚本中之前定义的命令会被静默替换. 


:delc[ommand] {cmd}				*:delc* *:delcommand* *E184*
			删除用户自定义命令{cmd}. 这在列出命令时被禁止, 比如: 
			从计时器中删除命令. *E1311*

:delc[ommand] -buffer {cmd}					*E1237*
			删除为当前buffer定义的用户自定义命令{cmd}

:comc[lear]						*:comc* *:comclear*
			删除所有用户自定义命令.


命令属性 ~
							*command-attributes*
用户自定义命令被Vim像其他命令一样对待. 它们可以有参数或指定范围. 参数通常是文件名
缓冲区等等. 命令具体如何生效取决于命令的属性, 这在命令被定义时便被指定了. 

当在脚本中定义一个用户命令, 它就能调用脚本中的局部函数和局部映射. 当用户调用
用户自定义命令时, 它会在它被定义的脚本上下文中运行. 这关系到|<SID>|是否在命令中
被用到. 

有许多的属性, 它们被分为4类: 处理参数、补全行为、处理范围及特殊场景. 下面按属性
分类描述描述. 


Argument handling|处理参数 ~
						*E175* *E176* *:command-nargs*
命令默认不带参数 (如果被指定参数的话就会报错). 然而, 使用-nargs属性则可以指定
命令可以接受参数. 有效的场景如: 

	-nargs=0    禁止参数 (默认) 
	-nargs=1    正好要求一个参数, 它包含空格
	-nargs=*    接受任意数量的被空格分隔的参数 (0, 1或这更多) 
	-nargs=?    接受0 或 1 个参数
	-nargs=+    必须指定参数, 但接受任意数量的参数

参数被认为是被(未转义的)当前上下文的空格或制表符分隔的, 除非只有一个参数, 那空格
就是参数的一部分. 

注意参数是以文本的形式使用的而不是表达式. 尤其是"s:var"将会使用命令被定义的脚本
中的局部变量而不是被调用时的脚本中的局部变量. 比如: 
    script1.vim: >
	:let s:error = "None"
	:command -nargs=1 Error echoerr <args>
<   script2.vim: >
	:source script1.vim
	:let s:error = "Wrong!"
	:Error s:error
执行script2.vim将会导致"None"被打印. 而不是你想要的打印"Wrong!". 调用函数可能是
可选方案. 


Completion behavior|补全行为 ~
				*:command-completion* *E179* *E180* *E181*
				*:command-complete*
默认的, 用户自定义命令的参数没有自动补全. 然而, 通过指定下面中的一个属性及可实现
参数补全: 

	-complete=arglist	file names in argument list
	-complete=augroup	autocmd groups
	-complete=behave	|:behave| suboptions
	-complete=breakpoint	|:breakadd| suboptions
	-complete=buffer	buffer names
	-complete=color		color schemes
	-complete=command	Ex command (and arguments)
	-complete=compiler	compilers
	-complete=cscope	|:cscope| suboptions
	-complete=diff_buffer	diff buffer names
	-complete=dir		directory names
	-complete=dir_in_path	directory names in |'cdpath'|
	-complete=environment	environment variable names
	-complete=event		autocommand events
	-complete=expression	Vim expression
	-complete=file		file and directory names
	-complete=file_in_path	file and directory names in |'path'|
	-complete=filetype	filetype names |'filetype'|
	-complete=function	function name
	-complete=help		help subjects
	-complete=highlight	highlight groups
	-complete=history	|:history| suboptions
	-complete=keymap	keyboard mappings
	-complete=locale	locale names (as output of locale -a)
	-complete=mapclear	buffer argument
	-complete=mapping	mapping name
	-complete=menu		menus
	-complete=messages	|:messages| suboptions
	-complete=option	options
	-complete=packadd	optional package |pack-add| names
	-complete=runtime	file and directory names in |'runtimepath'|
	-complete=scriptnames	sourced script names
	-complete=shellcmd	Shell command
	-complete=shellcmdline	First is a shell command and subsequent ones
				are filenames. The same behavior as |:!cmd|
	-complete=sign		|:sign| suboptions
	-complete=syntax	syntax file names |'syntax'|
	-complete=syntime	|:syntime| suboptions
	-complete=tag		tags
	-complete=tag_listfiles	tags, file names are shown when CTRL-D is hit
	-complete=user		user names
	-complete=var		user variables
	-complete=custom,{func} custom completion, defined via {func}
	-complete=customlist,{func} custom completion, defined via {func}

如果指定补全但是缺没有补全项 (-nargs=0, 默认值) 之后会抛出一个错误 *E1208*
注意: 一些补全方法可能会扩展环境变量. 


Custom completion|自定义补全 ~
				*:command-completion-custom*
				*:command-completion-customlist* *E467* *E468*
可以通过"custom,{func}"或"customlist,{func}"补全参数定义自定义补全. {func}部分
应该为具有下面特征的函数: >

	:function {func}(ArgLead, CmdLine, CursorPos)

函数并不需要使用全部参数. 函数应该提供补全候选作为返回值. 

对于"custom"参数, 函数应该返回一个以换行符分隔的每行一个补全候选的字符串. 
							*E1303*
对于"customlist"参数, 函数应该返回一个包含补全候选的列表. 空字符串项则被忽略. 

函数参数为: 
	ArgLead		当前用于补全的参数的首部
	CmdLine		整个命令行
	CursorPos	补全内容的光标索引(字节索引)
函数可能用这些来确定上下文. 对于"custom"参数, 用ArgLead(隐式规则)过滤补全候选
不是必需的. Vim会用自带的正则引擎在函数返回后过滤补全候选, 在大多数情况下这可能
更高效. 如果'wildoptions'选项包含"fuzzy", 那补全候选将会被|fuzzy-matching|过滤.
对于"customlist"参数, Vim不会过滤被返回的补全候选, 它应该被用户提供的函数过滤. 

下面的例子使用Finger命令列出用户名称 >
    :com -complete=custom,ListUsers -nargs=1 Finger !finger <args>
    :fun ListUsers(A,L,P)
    :    return system("cut -d: -f1 /etc/passwd")
    :endfun

下面的例子则从'path'选项指定的目录中补全文件名: >
    :com -nargs=1 -bang -complete=customlist,EditFileComplete
			\ EditFile edit<bang> <args>
    :fun EditFileComplete(A,L,P)
    :    return split(globpath(&path, a:A), "\n")
    :endfun
<
这个例子在文件名包含空格时不会生效. 


Range handling|范围处理 ~
				*E177* *E178* *:command-range* *:command-count*
用户自定义命令默认并不接受行号范围. 然而, 命令接受在行号位置(-range=N, 类似
|:split|命令)指定范围(-range属性)或任意计数值作为一个"计数"参数(-count=N, 类似
|:Next|命令)是可能的. 计数之后将会在参数中以|<count>|形式被访问. 

可能的属性如下: 

	-range	    Range allowed, default is current line
	-range=%    Range allowed, default is whole file (1,$)
	-range=N    A count (default N) which is specified in the line
		    number position (like |:split|); allows for zero line
		    number.
	-count=N    A count (default N) which is specified either in the line
		    number position, or as an initial argument (like |:Next|).
	-count	    Acts like -count=0

注意: -range=N及-count=N是彼此不能共存的 - 只能指定其中一个. 

					*:command-addr*
范围中的特殊字符像 ., $, %默认对应着当前行、最后一行及整个buffer关联上参数、
(已加载)缓冲区, 窗口及标签页是可能的. 

可能的值如下 (第二列是用于列表[指使用:com命令显示所有自定义命令的列表]的缩写) : 
    -addr=lines			Range of lines (this is the default for -range)
    -addr=arguments	  arg	Range for arguments
    -addr=buffers	  buf	Range for buffers (also not loaded buffers)
    -addr=loaded_buffers  load	Range for loaded buffers
    -addr=windows	  win	Range for windows
    -addr=tabs		  tab	Range for tab pages
    -addr=quickfix	  qf	Range for quickfix entries
    -addr=other		  ?	Other kind of range; can use ".", "$" and "%"
				as with "lines" (this is the default for
				-count)


Special cases|特殊情况 ~
					*:command-bang* *:command-bar*
					*:command-register* *:command-buffer*
					*:command-keepscript*
自定义命令也存在一些特殊情况: 

	-bang	    The command can take a ! modifier (like :q or :w)
	-bar	    The command can be followed by a "|" and another command.
		    A "|" inside the command argument is not allowed then.
		    Also checks for a " to start a comment.
	-register   The first argument to the command can be an optional
		    register name (like :del, :put, :yank).
	-buffer	    The command will only be available in the current buffer.
	-keepscript Do not use the location of where the user command was
		    defined for verbose messages, use the location of where
		    the user command was invoked.

在指定-count和-register属性的情况下, 如果可选参数被提供了, 它将会从参数列表中被
移除且仅可被替换文本{repl}单独访问. 
注意这些参数可以被缩写, 但那是一个被废弃的特性. 在新的脚本中请使用参数全名. 


Replacement text|替换文本 ~
							*:command-repl*
{repl}参数通常是一个可能带"|"分隔命令的长字符串, 一个特殊的例子就是如果参数是"{"
那么接下来的行直到以"}"开始的行都会被使用并且应用|Vim9|语法. 比如: >
	:command MyCommand {
		echo 'hello'
		g:calledMyCommand = true
	    }
<							*E1231*
在"{"前面必须有空白字符. 不支持嵌套, 也不能使用内联函数. "|"可能出现在参数中的
命令比如带有表达式参数的命令不能使用"|"符号用于分隔其他命令. 

如果命令是被定义在Vim9脚本中 (脚本以`:vim9script`且在`:def`申明的函数中), 
那么{repl}将会在Vim9脚本中被执行. 因此这取决于命令被定义的地方而非被调用的地方.

用于用户自定义命令的替换文本{repl}被使用<...>标记扫描查找特殊转义序列. 转义序列
被替换为来从命令行键入的值, 且其他文本被原封不动的复制. 结果字符串会被作为Ex命令
执行. 在初始的<的位置使用<lt>以避免替换.因此使用"<lt>bang>"包含"<bang>"字面量.

有效的转义序列如下: 

						*<line1>*
	<line1>	The starting line of the command range.
						*<line2>*
	<line2>	The final line of the command range.
						*<range>*
	<range> The number of items in the command range: 0, 1 or 2
						*<count>*
	<count>	Any count supplied (as described for the '-range'
		and '-count' attributes).
						*<bang>*
	<bang>	(See the '-bang' attribute) Expands to a ! if the
		command was executed with a ! modifier, otherwise
		expands to nothing.
					*<mods>* *<q-mods>* *:command-modifiers*
	<mods>  The command modifiers, if specified. Otherwise, expands to
		nothing. Supported modifiers are |:aboveleft|, |:belowright|,
		|:botright|, |:browse|, |:confirm|, |:hide|, |:horizontal|,
		|:keepalt|, |:keepjumps|, |:keepmarks|, |:keeppatterns|,
		|:leftabove|, |:lockmarks|, |:noautocmd|, |:noswapfile|,
		|:rightbelow|, |:sandbox|, |:silent|, |:tab|, |:topleft|,
		|:unsilent|, |:verbose|, and |:vertical|.
		Note that |:filter| is not supported.
		Examples: >
		    command! -nargs=+ -complete=file MyEdit
				\ for f in expand(<q-args>, 0, 1) |
				\ exe '<mods> split ' .. f |
				\ endfor

		    function! SpecialEdit(files, mods)
			for f in expand(a:files, 0, 1)
			    exe a:mods .. ' split ' .. f
			endfor
		    endfunction
		    command! -nargs=+ -complete=file Sedit
				\ call SpecialEdit(<q-args>, <q-mods>)
<
						*<reg>* *<register>*
	<reg>	(See the '-register' attribute) The optional register,
		if specified.  Otherwise, expands to nothing.  <register>
		is a synonym for this.
						*<args>*
	<args>	The command arguments, exactly as supplied (but as
		noted above, any count or register can consume some
		of the arguments, which are then not part of <args>).
	<lt>	A single '<' (Less-Than) character.  This is needed if you
		want to get a literal copy of one of these escape sequences
		into the expansion - for example, to get <bang>, use
		<lt>bang>.

							*<q-args>*
如果转义序列的前两个字符是"q-" (比如, <q-args>)那么值将会被用引号包裹以确保其在
表达式中有效. 这会将参数座椅单个值. 当没有参数时<q-args>是一个空字符串.
查阅下面的|q-args-example|文档. 
							*<f-args>*
为了允许命令传递它们的参数到用户自定义函数, 有一种特殊的格式<f-args>("函数参数")
这会以空格、制表符命令参数并将参数单独的用引号引用, 并且<f-args>序列被以逗号分隔的
被引用参数替换. 查看下面的Mycmd案例. 如果没有参数被指定<f-args>则会被移除.
为了嵌入空白符到<f-args>的参数中, 前置一个反斜杠. <f-args>会用一个反斜杠替换
每一对反斜杠(\\). 反斜杠后续的字符除了空白字符或反斜杠均保持字面意义. 同时查阅
下面的|f-args-example|文档. 预览: 

	command		   <f-args> ~
	XX ab		   'ab'
	XX a\b		   'a\b'
	XX a\ b		   'a b'
	XX a\  b	   'a ', 'b'
	XX a\\b		   'a\b'
	XX a\\ b	   'a\', 'b'
	XX a\\\b	   'a\\b'
	XX a\\\ b	   'a\ b'
	XX a\\\\b	   'a\\b'
	XX a\\\\ b	   'a\\', 'b'
	XX		   [nothing]


注意如果"no arguments"状况要被处理时, 必须确保函数能被无参数调用. 对于被编译的
函数这可能需要使用变量参数, 查阅文档|vim9-variable-arguments|. 

用户命令样例: >

   " Delete everything after here to the end
   :com Ddel +,$d

   " Rename the current buffer
   :com -nargs=1 -bang -complete=file Ren f <args>|w<bang>

   " Replace a range with the contents of a file
   " (Enter this all as one line)
   :com -range -nargs=1 -complete=file
	 Replace <line1>-pu_|<line1>,<line2>d|r <args>|<line1>d

   " Count the number of lines in the range
   :com! -range -nargs=0 Lines  echo <line2> - <line1> + 1 "lines"

<						*f-args-example*
调用用户函数 (<f-args>样例) >
   :com -nargs=* Mycmd call Myfunc(<f-args>)

当被如下方式执行时: >
	:Mycmd arg1 arg2
这会产生如下调用: >
	:call Myfunc("arg1","arg2")

<						*q-args-example*
更实用的例子: >
   :function Allargs(command)
   :   let i = 0
   :   while i < argc()
   :	  if filereadable(argv(i))
   :	     execute "e " .. argv(i)
   :	     execute a:command
   :      endif
   :      let i = i + 1
   :   endwhile
   :endfunction
   :command -nargs=+ -complete=command Allargs call Allargs(<q-args>)

命令Allargs接受任意Vim命令作为参数并且在参数列表的所有文件上执行. 使用样例: >
(注意使用"e"标识符以忽略错误并且"update"命令用于将被更改的缓冲区写入文件) 
	:Allargs %s/foo/bar/ge|update
这将会调用: >
	:call Allargs("%s/foo/bar/ge|update")
<

 vim:tw=78:ts=8:noet:ft=help:norl:
