# 一些术语
通配符匹配   globbing
通配符      wildcard
进程列表    p114  $BASH_SUBSHELL显示子 Shell 的嵌套深度，调用脚本、使用括号 () 、{command;} 或启动子进程都会增加该值
命令分组    command grouping
协程        coproc
衍生        forking
外部命令&内建命令 type type # type查看自身的命令类型 (type命令本身就用于显示命令信息)  which则是显示PATH中的命令路径
!! 应该在bash中被自动替换为上一条执行的命令 type !! 查询的是上一条命令  正常调用则是换回命令并执行该命令
!n  类似于!! 调用history中的第n条命令

环境变量  
printenv env

设置局部变量 var_name=value   # 存在空格则需要将变量值用 '' "" 包裹变量值

设置全局变量 export var_name  # man export

数组变量  
- 定义 var_name=(var1 var2 var3)   
- 引用 echo ${var_name[0]}  #应用仍与其他语言一样 引用全部元素 echo ${var_name[*]}
- 修改元素  var_name[0]=var4
- 删除元素  unset var_name[0] #删除元素只是将其值置空 并不会将剩余索引左移

# 文件权限
## 文件模式
属主|属组|其他  
- 都是控制rwx即读写执行，linux默认给文件的权限为666，给文件夹的权限为777
- 用户创建的文件权限为  default & ~ umask 权限
  - 如，系统默认umask为 022 顾文件权限  umask 000|010|010   文件夹权限  umask  000|010|010
                                       ~umask 111|101|101              ~umask  111|101|101
                                      default 110|110|110             default  111|111|111
                                     最终权限 110|100|100            最终权限  111|101|101
                                     即       rw- r-- r--            即        rwx r-x r-w

umask: 设置或显示文件权限掩码
- archlinux 的默认设置为 022 @ /etc/login.defs

权限位：文件权限由4位8进制数组成即权限位、属主位、属组位、其他位，
而修改文件权限只需要1~4位八进制数就行，系统默认会补足前置零
- 权限位的的比特位  第一位为文件执行      是否采用属主权限
                    第二位为文件执行      是否采用属组权限 文件夹内新建是否将当前属组作为默认属组
                    第三位为粘滞位        是否只能由属组删除或重命名文件夹内文件

## 文件系统管理和软件安装跳过
## 
## 脚本
默认的shell环境变量 p133
1. 赋值与引用           var1=value1       var2=$var1
2. 命令替换
  - 获取命令输出结果    $(date) `date`  如获取日期作为程序日志的文件名 ls > log-$(date)
  - 不知道命令替换是否为进程列表的值引用 $()  前者引用值  后者启用子进程
3. 重定向
  - 输出重定向
  - 输入重定向
    - <
    - 内联输入重定向 inline input redirection，该输入重定向需要文本标识符界定起止位置如：
      wc << EOF
        input 1
        input 2
        EOF
        这里的内联重定向采用的文本标识符就是EOF
4. 管道 与输出重定向差不多的表现形式 前者为数据流向进程而后者数据流向文件
5. 数学运算 bash只是处理命令，数学运算需要命令支持而非bash自身支持
  5.1. expr 命令
    这里列的运算符号只是该命令的选项，具体含义参考man文档
    支持的运算符号  |   与管道符含义重合，需转义      逻辑或  与js的  || 类似返回第一个真值或最后一个假值
                    &   与后台运行符含义重合，需转义  逻辑与          &&         全真则返回第一个真值否则返回0，与js有点差异
                    <   与输入重定向含义重合，需转义  小于
                    <=  需转义
                    =
                    !=
                    >=  
                    >   与输出重定向含义重合，需转义
                    +
                    -
                    *   与通配符 * 含义重合，需转义
                    /
                    %   取模
                    STRING : REGEXP       如果REGEXP匹配字符串则返回模式匹配的内容
                    match STRING REGEXP   如果REGEXP匹配字符串则返回模式匹配的内容
                    substr STRING POS LENGTH  返回指定位置开始指定长度的子串
                    index STRING SUBSTR   返回子串在字符串中出现的位置
                    length STRING         返回字符串的长度
                    + TOKEN               将TOKEN解释成字符串，即使TOKEN属于关键字
                    (EXPRESSION)          返回EXPRESSION的值，与上面的其他符号一样，()需要转义不然会被认为是进程列表
  5.2 方括号运算  $()命令替换 $[]数学运算
    $[ 1 + 5 ]    无论是反括号运算还是expr命令，这两者均只支持整数运算
  5.3 浮点数
    - bc  任意精度计算器语言    arbitrary precision calculator language 这里不展开了
      内置变量scale用来控制结果精度
      变量引用无需采用$前缀
      在脚本中的使用方式  variable=$(echo "options; expression"|bc) 即将变量和表达式传给bc命令
                          如  var1=$(echo "scale=4;4 / 5"|bc)
                          这里的表达式会被当作整体对待即无需采用空格以区分不同参数
6. 退出脚本
  $?  保存程序退出状态码  具体状态码的含义见书 表 11-2
  exit 5  手动指定退出状态码
  状态码的值范围为 0~255即一个字节
7. 条件语句
  test命令功能很强  另一种写法 [ expression ] ，
  - test命令总体上分为三种类型比较  
  1. 数值   -gt -lt
  2. 字符串 = < > -n  字符串处理比较应该套上"" , 感觉bash的行为逻辑是先引用变量然后在执行命令
  3. 文件   
    查看test的用户手册是发现几个概念，这里记录下后续在深入学习
    1. id           如uid、gid  用户的真实id 进程启动者
    2. set-id         set-user-ID、set-group-ID 通过权限位设置的执行id  进程执行者
    3. effective id   effective user ID、effective group ID 文件能被执行者
    前者相对与用户层面而后两者相对于程序进程执行层面
8. 复合条件语句
  复合条件语句依靠两个布尔运算符:
  - &&:逻辑与 任意调价为假则为假  否则真
  - ||:逻辑或 任意条件为真则为真  否则假
9. 条件语句的高级特性
  9.1. 在子shell执行命令的()
    进程列表相关，使用()启用子shell，与命令替换$()区分，前者执行子shell而后者获取子shell的值
    用在条件语句中则自动取其返回状态码，成功则为0否则为其他值
    *注意 进程列表只返回最后一个进程的状态码*
  9.2. 使用双括号 (())
    允许使用高级数学表达式  见表12-4 双括号命令符号
  9.3. 使用双方括号 [[]]
    允许字符串比较的高级特性，模式匹配即正则表达式
  感觉9.2和9.3就是对test命令[]的补充
    [[ ]] 注意与test命令[]区分
10. case命令
  通用格式：case word in [ [(] pattern [ | pattern ] ...) list ;;] ...esac
    关键字：----      --    -            -              -      --     ----
    程序数据     ----          -------     -------        ----  
    需要注意的是  | 操作符可以传入多个匹配模式
                 ;; 出口操作符并不唯一，另外两种形式;&  ;;&
                直接跳出            执行下个匹配指令集  继续向下匹配
                一般来说()是成对出现的，但是在case语句的pattern中前括号可省略且推荐省略
                这样即可表达case的pattern语义作用

login shell       p13





































